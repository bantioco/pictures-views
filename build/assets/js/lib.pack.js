/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function ($) {\n\n    $.fn.viewsPictures = function (options) {\n\n        /*************************************\n            Options plugin..\n        *************************************/\n        var config = {\n            \"bgColor\": \"#BABABA\",\n            \"speedImg\": 400,\n            \"effectImg\": \"slide\",\n            \"navColor\": \"#000000\",\n            \"callback\": null\n        };\n        var params = $.extend(config, options);\n        /************************************/\n\n        function makeid() {\n            var text = \"\";\n            var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n            for (var i = 0; i < 5; i++) {\n                text += possible.charAt(Math.floor(Math.random() * possible.length));\n            }return text;\n        }\n\n        var uniqId = makeid();\n\n        /*************************************\n            Add block slide picture\n        *************************************/\n        var block_picture = '<div id=\"' + uniqId + '\" class=\"screen_root\">' + '<div class=\"screen_nav_left\" style=\"color:' + params.navColor + '\"></div>' + '<ul class=\"screen_block\"></ul>' + '<div class=\"screen_nav_right\" style=\"color:' + params.navColor + '\"></div>' + '</div>';\n\n        $('body').append(block_picture);\n        /************************************/\n\n        /*************************************\n            Add background..\n        *************************************/\n        var block_background = '<div class=\"screen_bg\" style=\"background-color:' + params.bgColor + '\"></div>';\n        $(\"#\" + uniqId).append(block_background);\n        /************************************/\n\n        return this.find('img').each(function (i, e) {\n\n            var d = i + 1;\n\n            $(this).attr('data-screen', d);\n\n            var src = $(e).attr('src');\n            var id = i + 1;\n\n            $(\"#\" + uniqId).find('ul.screen_block').append('<li data-screen=\"' + d + '\" id=\"screen_' + id + '\" class=\"screen_list\"><img class=\"screen_img\" src=\"' + src + '\" /></li>');\n\n            $(this).off('click').on('click', function () {\n\n                var c = $(this).attr('data-screen');\n\n                $('.screen_bg').fadeIn(300, function () {\n\n                    if (params.effectImg === \"slide\") {\n\n                        $('.screen_root').fadeIn(300, function () {\n                            $('ul.screen_block').children('li[data-screen=\"' + c + '\"]').slideDown(params.speedImg);\n                        });\n                    } else if (params.effectImg === \"fade\") {\n                        $('.screen_root').fadeIn(300, function () {\n                            $('ul.screen_block').children('li[data-screen=\"' + c + '\"]').fadeIn(params.speedImg);\n                        });\n                    }\n\n                    /****************\n                        UI Effect\n                    ****************/\n                    else if (params.effectImg === \"bounce\") {\n                            $('.screen_root').fadeIn(300, function () {\n                                $('ul.screen_block').children('li[data-screen=\"' + c + '\"]').fadeIn(params.speedImg).effect('bounce');\n                            });\n                        } else {\n                            $('.screen_root').fadeIn(300, function () {\n                                $('ul.screen_block').children('li[data-screen=\"' + c + '\"]').slideDown(params.speedImg);\n                            });\n                        }\n                });\n            });\n\n            $(\"#\" + uniqId).off('click', '.screen_bg').on('click', '.screen_bg', function () {\n\n                $('ul.screen_block').children('li').fadeOut(300, function () {\n                    $('.screen_root').fadeOut(300, function () {\n                        $('.screen_bg').fadeOut(300);\n                        $('li.screen_list').hide();\n                    });\n                });\n            });\n\n            $(\"#\" + uniqId).off('click', '.screen_nav_right').on('click', '.screen_nav_right', function () {\n\n                var g = $('ul.screen_block').children('li:visible').attr('data-screen');\n                var o = parseInt(g) + 1;\n                var timeOut = params.speedImg + 100;\n\n                if (params.effectImg === \"slide\") {\n\n                    $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').slideUp(params.speedImg);\n\n                    if (o <= $('li.screen_list').length || o == NaN) {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').slideDown(params.speedImg);\n                        }, timeOut);\n                    } else {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li:first').slideDown(params.speedImg);\n                        }, timeOut);\n                    }\n                } else if (params.effectImg === \"fade\") {\n\n                    $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').fadeOut(params.speedImg);\n\n                    if (o <= $('li.screen_list').length || o == NaN) {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').fadeIn(params.speedImg);\n                        }, timeOut);\n                    } else {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li:first').fadeIn(params.speedImg);\n                        }, timeOut);\n                    }\n                }\n\n                /****************\n                    UI Effect\n                ****************/\n                else if (params.effectImg === \"bounce\") {\n\n                        $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').fadeOut(params.speedImg);\n\n                        if (o <= $('li.screen_list').length || o == NaN) {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').fadeIn(params.speedImg).effect('bounce');\n                            }, timeOut);\n                        } else {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li:first').fadeIn(params.speedImg).effect('bounce');\n                            }, timeOut);\n                        }\n                    } else {\n\n                        $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').slideUp(params.speedImg);\n\n                        if (o <= $('li.screen_list').length || o == NaN) {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').slideDown(params.speedImg);\n                            }, timeOut);\n                        } else {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li:first').slideDown(params.speedImg);\n                            }, timeOut);\n                        }\n                    }\n            });\n\n            $(\"#\" + uniqId).off('click', '.screen_nav_left').on('click', '.screen_nav_left', function () {\n\n                var g = $('ul.screen_block').children('li:visible').attr('data-screen');\n                var o = parseInt(g) - 1;\n                var timeOut = params.speedImg + 100;\n\n                if (params.effectImg === \"slide\") {\n\n                    $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').slideUp(params.speedImg);\n\n                    if (o >= 1) {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').slideDown(params.speedImg);\n                        }, timeOut);\n                    } else {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li:last').slideDown(params.speedImg);\n                        }, timeOut);\n                    }\n                } else if (params.effectImg === \"fade\") {\n\n                    $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').fadeOut(params.speedImg);\n\n                    if (o >= 1) {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').fadeIn(params.speedImg);\n                        }, timeOut);\n                    } else {\n                        setTimeout(function () {\n                            $('ul.screen_block').children('li:last').fadeIn(params.speedImg);\n                        }, timeOut);\n                    }\n                }\n\n                /****************\n                    UI Effect\n                ****************/\n                else if (params.effectImg === \"bounce\") {\n\n                        $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').fadeOut(params.speedImg);\n\n                        if (o >= 1) {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').fadeIn(params.speedImg).effect('bounce');\n                            }, timeOut);\n                        } else {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li:last').fadeIn(params.speedImg).effect('bounce');\n                            }, timeOut);\n                        }\n                    } else {\n\n                        $('ul.screen_block').children('li[data-screen=\"' + g + '\"]').slideUp(params.speedImg);\n\n                        if (o >= 1) {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li[data-screen=\"' + o + '\"]').slideDown(params.speedImg);\n                            }, timeOut);\n                        } else {\n                            setTimeout(function () {\n                                $('ul.screen_block').children('li:last').slideDown(params.speedImg);\n                            }, timeOut);\n                        }\n                    }\n            });\n        });\n    };\n})(jQuery);\n\n/*******************************\n    INCLUDE jQUERY UI\n*******************************/\n(function ($) {\n\n    $.ui = $.ui || {};\n\n    var version = $.ui.version = \"1.12.1\";\n\n    /*!\n     * jQuery UI Effects 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Effects Core\n    //>>group: Effects\n    // jscs:disable maximumLineLength\n    //>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.\n    // jscs:enable maximumLineLength\n    //>>docs: http://api.jqueryui.com/category/effects-core/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var dataSpace = \"ui-effects-\",\n        dataSpaceStyle = \"ui-effects-style\",\n        dataSpaceAnimated = \"ui-effects-animated\",\n\n\n    // Create a local jQuery because jQuery Color relies on it and the\n    // global may not exist with AMD and a custom build (#10199)\n    jQuery = $;\n\n    $.effects = {\n        effect: {}\n    };\n\n    /*!\n     * jQuery Color Animations v2.1.2\n     * https://github.com/jquery/jquery-color\n     *\n     * Copyright 2014 jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     *\n     * Date: Wed Jan 16 08:47:09 2013 -0600\n     */\n    (function (jQuery, undefined) {\n\n        var stepHooks = \"backgroundColor borderBottomColor borderLeftColor borderRightColor \" + \"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor\",\n\n\n        // Plusequals test for += 100 -= 100\n        rplusequals = /^([\\-+])=\\s*(\\d+\\.?\\d*)/,\n\n\n        // A set of RE's that can match strings and generate color tuples.\n        stringParsers = [{\n            re: /rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n            parse: function parse(execResult) {\n                return [execResult[1], execResult[2], execResult[3], execResult[4]];\n            }\n        }, {\n            re: /rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n            parse: function parse(execResult) {\n                return [execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4]];\n            }\n        }, {\n\n            // This regex ignores A-F because it's compared against an already lowercased string\n            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\n            parse: function parse(execResult) {\n                return [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)];\n            }\n        }, {\n\n            // This regex ignores A-F because it's compared against an already lowercased string\n            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\n            parse: function parse(execResult) {\n                return [parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16)];\n            }\n        }, {\n            re: /hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n            space: \"hsla\",\n            parse: function parse(execResult) {\n                return [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]];\n            }\n        }],\n\n\n        // JQuery.Color( )\n        color = jQuery.Color = function (color, green, blue, alpha) {\n            return new jQuery.Color.fn.parse(color, green, blue, alpha);\n        },\n            spaces = {\n            rgba: {\n                props: {\n                    red: {\n                        idx: 0,\n                        type: \"byte\"\n                    },\n                    green: {\n                        idx: 1,\n                        type: \"byte\"\n                    },\n                    blue: {\n                        idx: 2,\n                        type: \"byte\"\n                    }\n                }\n            },\n\n            hsla: {\n                props: {\n                    hue: {\n                        idx: 0,\n                        type: \"degrees\"\n                    },\n                    saturation: {\n                        idx: 1,\n                        type: \"percent\"\n                    },\n                    lightness: {\n                        idx: 2,\n                        type: \"percent\"\n                    }\n                }\n            }\n        },\n            propTypes = {\n            \"byte\": {\n                floor: true,\n                max: 255\n            },\n            \"percent\": {\n                max: 1\n            },\n            \"degrees\": {\n                mod: 360,\n                floor: true\n            }\n        },\n            support = color.support = {},\n\n\n        // Element for support tests\n        supportElem = jQuery(\"<p>\")[0],\n\n\n        // Colors = jQuery.Color.names\n        colors,\n\n\n        // Local aliases of functions called often\n        each = jQuery.each;\n\n        // Determine rgba support immediately\n        supportElem.style.cssText = \"background-color:rgba(1,1,1,.5)\";\n        support.rgba = supportElem.style.backgroundColor.indexOf(\"rgba\") > -1;\n\n        // Define cache name and alpha properties\n        // for rgba and hsla spaces\n        each(spaces, function (spaceName, space) {\n            space.cache = \"_\" + spaceName;\n            space.props.alpha = {\n                idx: 3,\n                type: \"percent\",\n                def: 1\n            };\n        });\n\n        function clamp(value, prop, allowEmpty) {\n            var type = propTypes[prop.type] || {};\n\n            if (value == null) {\n                return allowEmpty || !prop.def ? null : prop.def;\n            }\n\n            // ~~ is an short way of doing floor for positive numbers\n            value = type.floor ? ~~value : parseFloat(value);\n\n            // IE will pass in empty strings as value for alpha,\n            // which will hit this case\n            if (isNaN(value)) {\n                return prop.def;\n            }\n\n            if (type.mod) {\n\n                // We add mod before modding to make sure that negatives values\n                // get converted properly: -10 -> 350\n                return (value + type.mod) % type.mod;\n            }\n\n            // For now all property types without mod have min and max\n            return 0 > value ? 0 : type.max < value ? type.max : value;\n        }\n\n        function stringParse(string) {\n            var inst = color(),\n                rgba = inst._rgba = [];\n\n            string = string.toLowerCase();\n\n            each(stringParsers, function (i, parser) {\n                var parsed,\n                    match = parser.re.exec(string),\n                    values = match && parser.parse(match),\n                    spaceName = parser.space || \"rgba\";\n\n                if (values) {\n                    parsed = inst[spaceName](values);\n\n                    // If this was an rgba parse the assignment might happen twice\n                    // oh well....\n                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];\n                    rgba = inst._rgba = parsed._rgba;\n\n                    // Exit each( stringParsers ) here because we matched\n                    return false;\n                }\n            });\n\n            // Found a stringParser that handled it\n            if (rgba.length) {\n\n                // If this came from a parsed string, force \"transparent\" when alpha is 0\n                // chrome, (and maybe others) return \"transparent\" as rgba(0,0,0,0)\n                if (rgba.join() === \"0,0,0,0\") {\n                    jQuery.extend(rgba, colors.transparent);\n                }\n                return inst;\n            }\n\n            // Named colors\n            return colors[string];\n        }\n\n        color.fn = jQuery.extend(color.prototype, {\n            parse: function parse(red, green, blue, alpha) {\n                if (red === undefined) {\n                    this._rgba = [null, null, null, null];\n                    return this;\n                }\n                if (red.jquery || red.nodeType) {\n                    red = jQuery(red).css(green);\n                    green = undefined;\n                }\n\n                var inst = this,\n                    type = jQuery.type(red),\n                    rgba = this._rgba = [];\n\n                // More than 1 argument specified - assume ( red, green, blue, alpha )\n                if (green !== undefined) {\n                    red = [red, green, blue, alpha];\n                    type = \"array\";\n                }\n\n                if (type === \"string\") {\n                    return this.parse(stringParse(red) || colors._default);\n                }\n\n                if (type === \"array\") {\n                    each(spaces.rgba.props, function (key, prop) {\n                        rgba[prop.idx] = clamp(red[prop.idx], prop);\n                    });\n                    return this;\n                }\n\n                if (type === \"object\") {\n                    if (red instanceof color) {\n                        each(spaces, function (spaceName, space) {\n                            if (red[space.cache]) {\n                                inst[space.cache] = red[space.cache].slice();\n                            }\n                        });\n                    } else {\n                        each(spaces, function (spaceName, space) {\n                            var cache = space.cache;\n                            each(space.props, function (key, prop) {\n\n                                // If the cache doesn't exist, and we know how to convert\n                                if (!inst[cache] && space.to) {\n\n                                    // If the value was null, we don't need to copy it\n                                    // if the key was alpha, we don't need to copy it either\n                                    if (key === \"alpha\" || red[key] == null) {\n                                        return;\n                                    }\n                                    inst[cache] = space.to(inst._rgba);\n                                }\n\n                                // This is the only case where we allow nulls for ALL properties.\n                                // call clamp with alwaysAllowEmpty\n                                inst[cache][prop.idx] = clamp(red[key], prop, true);\n                            });\n\n                            // Everything defined but alpha?\n                            if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {\n\n                                // Use the default of 1\n                                inst[cache][3] = 1;\n                                if (space.from) {\n                                    inst._rgba = space.from(inst[cache]);\n                                }\n                            }\n                        });\n                    }\n                    return this;\n                }\n            },\n            is: function is(compare) {\n                var is = color(compare),\n                    same = true,\n                    inst = this;\n\n                each(spaces, function (_, space) {\n                    var localCache,\n                        isCache = is[space.cache];\n                    if (isCache) {\n                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];\n                        each(space.props, function (_, prop) {\n                            if (isCache[prop.idx] != null) {\n                                same = isCache[prop.idx] === localCache[prop.idx];\n                                return same;\n                            }\n                        });\n                    }\n                    return same;\n                });\n                return same;\n            },\n            _space: function _space() {\n                var used = [],\n                    inst = this;\n                each(spaces, function (spaceName, space) {\n                    if (inst[space.cache]) {\n                        used.push(spaceName);\n                    }\n                });\n                return used.pop();\n            },\n            transition: function transition(other, distance) {\n                var end = color(other),\n                    spaceName = end._space(),\n                    space = spaces[spaceName],\n                    startColor = this.alpha() === 0 ? color(\"transparent\") : this,\n                    start = startColor[space.cache] || space.to(startColor._rgba),\n                    result = start.slice();\n\n                end = end[space.cache];\n                each(space.props, function (key, prop) {\n                    var index = prop.idx,\n                        startValue = start[index],\n                        endValue = end[index],\n                        type = propTypes[prop.type] || {};\n\n                    // If null, don't override start value\n                    if (endValue === null) {\n                        return;\n                    }\n\n                    // If null - use end\n                    if (startValue === null) {\n                        result[index] = endValue;\n                    } else {\n                        if (type.mod) {\n                            if (endValue - startValue > type.mod / 2) {\n                                startValue += type.mod;\n                            } else if (startValue - endValue > type.mod / 2) {\n                                startValue -= type.mod;\n                            }\n                        }\n                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);\n                    }\n                });\n                return this[spaceName](result);\n            },\n            blend: function blend(opaque) {\n\n                // If we are already opaque - return ourself\n                if (this._rgba[3] === 1) {\n                    return this;\n                }\n\n                var rgb = this._rgba.slice(),\n                    a = rgb.pop(),\n                    blend = color(opaque)._rgba;\n\n                return color(jQuery.map(rgb, function (v, i) {\n                    return (1 - a) * blend[i] + a * v;\n                }));\n            },\n            toRgbaString: function toRgbaString() {\n                var prefix = \"rgba(\",\n                    rgba = jQuery.map(this._rgba, function (v, i) {\n                    return v == null ? i > 2 ? 1 : 0 : v;\n                });\n\n                if (rgba[3] === 1) {\n                    rgba.pop();\n                    prefix = \"rgb(\";\n                }\n\n                return prefix + rgba.join() + \")\";\n            },\n            toHslaString: function toHslaString() {\n                var prefix = \"hsla(\",\n                    hsla = jQuery.map(this.hsla(), function (v, i) {\n                    if (v == null) {\n                        v = i > 2 ? 1 : 0;\n                    }\n\n                    // Catch 1 and 2\n                    if (i && i < 3) {\n                        v = Math.round(v * 100) + \"%\";\n                    }\n                    return v;\n                });\n\n                if (hsla[3] === 1) {\n                    hsla.pop();\n                    prefix = \"hsl(\";\n                }\n                return prefix + hsla.join() + \")\";\n            },\n            toHexString: function toHexString(includeAlpha) {\n                var rgba = this._rgba.slice(),\n                    alpha = rgba.pop();\n\n                if (includeAlpha) {\n                    rgba.push(~~(alpha * 255));\n                }\n\n                return \"#\" + jQuery.map(rgba, function (v) {\n\n                    // Default to 0 when nulls exist\n                    v = (v || 0).toString(16);\n                    return v.length === 1 ? \"0\" + v : v;\n                }).join(\"\");\n            },\n            toString: function toString() {\n                return this._rgba[3] === 0 ? \"transparent\" : this.toRgbaString();\n            }\n        });\n        color.fn.parse.prototype = color.fn;\n\n        // Hsla conversions adapted from:\n        // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\n\n        function hue2rgb(p, q, h) {\n            h = (h + 1) % 1;\n            if (h * 6 < 1) {\n                return p + (q - p) * h * 6;\n            }\n            if (h * 2 < 1) {\n                return q;\n            }\n            if (h * 3 < 2) {\n                return p + (q - p) * (2 / 3 - h) * 6;\n            }\n            return p;\n        }\n\n        spaces.hsla.to = function (rgba) {\n            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {\n                return [null, null, null, rgba[3]];\n            }\n            var r = rgba[0] / 255,\n                g = rgba[1] / 255,\n                b = rgba[2] / 255,\n                a = rgba[3],\n                max = Math.max(r, g, b),\n                min = Math.min(r, g, b),\n                diff = max - min,\n                add = max + min,\n                l = add * 0.5,\n                h,\n                s;\n\n            if (min === max) {\n                h = 0;\n            } else if (r === max) {\n                h = 60 * (g - b) / diff + 360;\n            } else if (g === max) {\n                h = 60 * (b - r) / diff + 120;\n            } else {\n                h = 60 * (r - g) / diff + 240;\n            }\n\n            // Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\n            // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\n            if (diff === 0) {\n                s = 0;\n            } else if (l <= 0.5) {\n                s = diff / add;\n            } else {\n                s = diff / (2 - add);\n            }\n            return [Math.round(h) % 360, s, l, a == null ? 1 : a];\n        };\n\n        spaces.hsla.from = function (hsla) {\n            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {\n                return [null, null, null, hsla[3]];\n            }\n            var h = hsla[0] / 360,\n                s = hsla[1],\n                l = hsla[2],\n                a = hsla[3],\n                q = l <= 0.5 ? l * (1 + s) : l + s - l * s,\n                p = 2 * l - q;\n\n            return [Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a];\n        };\n\n        each(spaces, function (spaceName, space) {\n            var props = space.props,\n                cache = space.cache,\n                to = space.to,\n                from = space.from;\n\n            // Makes rgba() and hsla()\n            color.fn[spaceName] = function (value) {\n\n                // Generate a cache for this space if it doesn't exist\n                if (to && !this[cache]) {\n                    this[cache] = to(this._rgba);\n                }\n                if (value === undefined) {\n                    return this[cache].slice();\n                }\n\n                var ret,\n                    type = jQuery.type(value),\n                    arr = type === \"array\" || type === \"object\" ? value : arguments,\n                    local = this[cache].slice();\n\n                each(props, function (key, prop) {\n                    var val = arr[type === \"object\" ? key : prop.idx];\n                    if (val == null) {\n                        val = local[prop.idx];\n                    }\n                    local[prop.idx] = clamp(val, prop);\n                });\n\n                if (from) {\n                    ret = color(from(local));\n                    ret[cache] = local;\n                    return ret;\n                } else {\n                    return color(local);\n                }\n            };\n\n            // Makes red() green() blue() alpha() hue() saturation() lightness()\n            each(props, function (key, prop) {\n\n                // Alpha is included in more than one space\n                if (color.fn[key]) {\n                    return;\n                }\n                color.fn[key] = function (value) {\n                    var vtype = jQuery.type(value),\n                        fn = key === \"alpha\" ? this._hsla ? \"hsla\" : \"rgba\" : spaceName,\n                        local = this[fn](),\n                        cur = local[prop.idx],\n                        match;\n\n                    if (vtype === \"undefined\") {\n                        return cur;\n                    }\n\n                    if (vtype === \"function\") {\n                        value = value.call(this, cur);\n                        vtype = jQuery.type(value);\n                    }\n                    if (value == null && prop.empty) {\n                        return this;\n                    }\n                    if (vtype === \"string\") {\n                        match = rplusequals.exec(value);\n                        if (match) {\n                            value = cur + parseFloat(match[2]) * (match[1] === \"+\" ? 1 : -1);\n                        }\n                    }\n                    local[prop.idx] = value;\n                    return this[fn](local);\n                };\n            });\n        });\n\n        // Add cssHook and .fx.step function for each named hook.\n        // accept a space separated string of properties\n        color.hook = function (hook) {\n            var hooks = hook.split(\" \");\n            each(hooks, function (i, hook) {\n                jQuery.cssHooks[hook] = {\n                    set: function set(elem, value) {\n                        var parsed,\n                            curElem,\n                            backgroundColor = \"\";\n\n                        if (value !== \"transparent\" && (jQuery.type(value) !== \"string\" || (parsed = stringParse(value)))) {\n                            value = color(parsed || value);\n                            if (!support.rgba && value._rgba[3] !== 1) {\n                                curElem = hook === \"backgroundColor\" ? elem.parentNode : elem;\n                                while ((backgroundColor === \"\" || backgroundColor === \"transparent\") && curElem && curElem.style) {\n                                    try {\n                                        backgroundColor = jQuery.css(curElem, \"backgroundColor\");\n                                        curElem = curElem.parentNode;\n                                    } catch (e) {}\n                                }\n\n                                value = value.blend(backgroundColor && backgroundColor !== \"transparent\" ? backgroundColor : \"_default\");\n                            }\n\n                            value = value.toRgbaString();\n                        }\n                        try {\n                            elem.style[hook] = value;\n                        } catch (e) {\n\n                            // Wrapped to prevent IE from throwing errors on \"invalid\" values like\n                            // 'auto' or 'inherit'\n                        }\n                    }\n                };\n                jQuery.fx.step[hook] = function (fx) {\n                    if (!fx.colorInit) {\n                        fx.start = color(fx.elem, hook);\n                        fx.end = color(fx.end);\n                        fx.colorInit = true;\n                    }\n                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));\n                };\n            });\n        };\n\n        color.hook(stepHooks);\n\n        jQuery.cssHooks.borderColor = {\n            expand: function expand(value) {\n                var expanded = {};\n\n                each([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (i, part) {\n                    expanded[\"border\" + part + \"Color\"] = value;\n                });\n                return expanded;\n            }\n        };\n\n        // Basic color names only.\n        // Usage of any of the other color names requires adding yourself or including\n        // jquery.color.svg-names.js.\n        colors = jQuery.Color.names = {\n\n            // 4.1. Basic color keywords\n            aqua: \"#00ffff\",\n            black: \"#000000\",\n            blue: \"#0000ff\",\n            fuchsia: \"#ff00ff\",\n            gray: \"#808080\",\n            green: \"#008000\",\n            lime: \"#00ff00\",\n            maroon: \"#800000\",\n            navy: \"#000080\",\n            olive: \"#808000\",\n            purple: \"#800080\",\n            red: \"#ff0000\",\n            silver: \"#c0c0c0\",\n            teal: \"#008080\",\n            white: \"#ffffff\",\n            yellow: \"#ffff00\",\n\n            // 4.2.3. \"transparent\" color keyword\n            transparent: [null, null, null, 0],\n\n            _default: \"#ffffff\"\n        };\n    })(jQuery);\n\n    /******************************************************************************/\n    /****************************** CLASS ANIMATIONS ******************************/\n    /******************************************************************************/\n    (function () {\n\n        var classAnimationActions = [\"add\", \"remove\", \"toggle\"],\n            shorthandStyles = {\n            border: 1,\n            borderBottom: 1,\n            borderColor: 1,\n            borderLeft: 1,\n            borderRight: 1,\n            borderTop: 1,\n            borderWidth: 1,\n            margin: 1,\n            padding: 1\n        };\n\n        $.each([\"borderLeftStyle\", \"borderRightStyle\", \"borderBottomStyle\", \"borderTopStyle\"], function (_, prop) {\n            $.fx.step[prop] = function (fx) {\n                if (fx.end !== \"none\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {\n                    jQuery.style(fx.elem, prop, fx.end);\n                    fx.setAttr = true;\n                }\n            };\n        });\n\n        function getElementStyles(elem) {\n            var key,\n                len,\n                style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,\n                styles = {};\n\n            if (style && style.length && style[0] && style[style[0]]) {\n                len = style.length;\n                while (len--) {\n                    key = style[len];\n                    if (typeof style[key] === \"string\") {\n                        styles[$.camelCase(key)] = style[key];\n                    }\n                }\n\n                // Support: Opera, IE <9\n            } else {\n                for (key in style) {\n                    if (typeof style[key] === \"string\") {\n                        styles[key] = style[key];\n                    }\n                }\n            }\n\n            return styles;\n        }\n\n        function styleDifference(oldStyle, newStyle) {\n            var diff = {},\n                name,\n                value;\n\n            for (name in newStyle) {\n                value = newStyle[name];\n                if (oldStyle[name] !== value) {\n                    if (!shorthandStyles[name]) {\n                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {\n                            diff[name] = value;\n                        }\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        // Support: jQuery <1.8\n        if (!$.fn.addBack) {\n            $.fn.addBack = function (selector) {\n                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n            };\n        }\n\n        $.effects.animateClass = function (value, duration, easing, callback) {\n            var o = $.speed(duration, easing, callback);\n\n            return this.queue(function () {\n                var animated = $(this),\n                    baseClass = animated.attr(\"class\") || \"\",\n                    applyClassChange,\n                    allAnimations = o.children ? animated.find(\"*\").addBack() : animated;\n\n                // Map the animated objects to store the original styles.\n                allAnimations = allAnimations.map(function () {\n                    var el = $(this);\n                    return {\n                        el: el,\n                        start: getElementStyles(this)\n                    };\n                });\n\n                // Apply class change\n                applyClassChange = function applyClassChange() {\n                    $.each(classAnimationActions, function (i, action) {\n                        if (value[action]) {\n                            animated[action + \"Class\"](value[action]);\n                        }\n                    });\n                };\n                applyClassChange();\n\n                // Map all animated objects again - calculate new styles and diff\n                allAnimations = allAnimations.map(function () {\n                    this.end = getElementStyles(this.el[0]);\n                    this.diff = styleDifference(this.start, this.end);\n                    return this;\n                });\n\n                // Apply original class\n                animated.attr(\"class\", baseClass);\n\n                // Map all animated objects again - this time collecting a promise\n                allAnimations = allAnimations.map(function () {\n                    var styleInfo = this,\n                        dfd = $.Deferred(),\n                        opts = $.extend({}, o, {\n                        queue: false,\n                        complete: function complete() {\n                            dfd.resolve(styleInfo);\n                        }\n                    });\n\n                    this.el.animate(this.diff, opts);\n                    return dfd.promise();\n                });\n\n                // Once all animations have completed:\n                $.when.apply($, allAnimations.get()).done(function () {\n\n                    // Set the final class\n                    applyClassChange();\n\n                    // For each animated element,\n                    // clear all css properties that were animated\n                    $.each(arguments, function () {\n                        var el = this.el;\n                        $.each(this.diff, function (key) {\n                            el.css(key, \"\");\n                        });\n                    });\n\n                    // This is guarnteed to be there if you use jQuery.speed()\n                    // it also handles dequeuing the next anim...\n                    o.complete.call(animated[0]);\n                });\n            });\n        };\n\n        $.fn.extend({\n            addClass: function (orig) {\n                return function (classNames, speed, easing, callback) {\n                    return speed ? $.effects.animateClass.call(this, { add: classNames }, speed, easing, callback) : orig.apply(this, arguments);\n                };\n            }($.fn.addClass),\n\n            removeClass: function (orig) {\n                return function (classNames, speed, easing, callback) {\n                    return arguments.length > 1 ? $.effects.animateClass.call(this, { remove: classNames }, speed, easing, callback) : orig.apply(this, arguments);\n                };\n            }($.fn.removeClass),\n\n            toggleClass: function (orig) {\n                return function (classNames, force, speed, easing, callback) {\n                    if (typeof force === \"boolean\" || force === undefined) {\n                        if (!speed) {\n\n                            // Without speed parameter\n                            return orig.apply(this, arguments);\n                        } else {\n                            return $.effects.animateClass.call(this, force ? { add: classNames } : { remove: classNames }, speed, easing, callback);\n                        }\n                    } else {\n\n                        // Without force parameter\n                        return $.effects.animateClass.call(this, { toggle: classNames }, force, speed, easing);\n                    }\n                };\n            }($.fn.toggleClass),\n\n            switchClass: function switchClass(remove, add, speed, easing, callback) {\n                return $.effects.animateClass.call(this, {\n                    add: add,\n                    remove: remove\n                }, speed, easing, callback);\n            }\n        });\n    })();\n\n    /******************************************************************************/\n    /*********************************** EFFECTS **********************************/\n    /******************************************************************************/\n\n    (function () {\n\n        if ($.expr && $.expr.filters && $.expr.filters.animated) {\n            $.expr.filters.animated = function (orig) {\n                return function (elem) {\n                    return !!$(elem).data(dataSpaceAnimated) || orig(elem);\n                };\n            }($.expr.filters.animated);\n        }\n\n        if ($.uiBackCompat !== false) {\n            $.extend($.effects, {\n\n                // Saves a set of properties in a data storage\n                save: function save(element, set) {\n                    var i = 0,\n                        length = set.length;\n                    for (; i < length; i++) {\n                        if (set[i] !== null) {\n                            element.data(dataSpace + set[i], element[0].style[set[i]]);\n                        }\n                    }\n                },\n\n                // Restores a set of previously saved properties from a data storage\n                restore: function restore(element, set) {\n                    var val,\n                        i = 0,\n                        length = set.length;\n                    for (; i < length; i++) {\n                        if (set[i] !== null) {\n                            val = element.data(dataSpace + set[i]);\n                            element.css(set[i], val);\n                        }\n                    }\n                },\n\n                setMode: function setMode(el, mode) {\n                    if (mode === \"toggle\") {\n                        mode = el.is(\":hidden\") ? \"show\" : \"hide\";\n                    }\n                    return mode;\n                },\n\n                // Wraps the element around a wrapper that copies position properties\n                createWrapper: function createWrapper(element) {\n\n                    // If the element is already wrapped, return it\n                    if (element.parent().is(\".ui-effects-wrapper\")) {\n                        return element.parent();\n                    }\n\n                    // Wrap the element\n                    var props = {\n                        width: element.outerWidth(true),\n                        height: element.outerHeight(true),\n                        \"float\": element.css(\"float\")\n                    },\n                        wrapper = $(\"<div></div>\").addClass(\"ui-effects-wrapper\").css({\n                        fontSize: \"100%\",\n                        background: \"transparent\",\n                        border: \"none\",\n                        margin: 0,\n                        padding: 0\n                    }),\n\n\n                    // Store the size in case width/height are defined in % - Fixes #5245\n                    size = {\n                        width: element.width(),\n                        height: element.height()\n                    },\n                        active = document.activeElement;\n\n                    // Support: Firefox\n                    // Firefox incorrectly exposes anonymous content\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n                    try {\n                        active.id;\n                    } catch (e) {\n                        active = document.body;\n                    }\n\n                    element.wrap(wrapper);\n\n                    // Fixes #7595 - Elements lose focus when wrapped.\n                    if (element[0] === active || $.contains(element[0], active)) {\n                        $(active).trigger(\"focus\");\n                    }\n\n                    // Hotfix for jQuery 1.4 since some change in wrap() seems to actually\n                    // lose the reference to the wrapped element\n                    wrapper = element.parent();\n\n                    // Transfer positioning properties to the wrapper\n                    if (element.css(\"position\") === \"static\") {\n                        wrapper.css({ position: \"relative\" });\n                        element.css({ position: \"relative\" });\n                    } else {\n                        $.extend(props, {\n                            position: element.css(\"position\"),\n                            zIndex: element.css(\"z-index\")\n                        });\n                        $.each([\"top\", \"left\", \"bottom\", \"right\"], function (i, pos) {\n                            props[pos] = element.css(pos);\n                            if (isNaN(parseInt(props[pos], 10))) {\n                                props[pos] = \"auto\";\n                            }\n                        });\n                        element.css({\n                            position: \"relative\",\n                            top: 0,\n                            left: 0,\n                            right: \"auto\",\n                            bottom: \"auto\"\n                        });\n                    }\n                    element.css(size);\n\n                    return wrapper.css(props).show();\n                },\n\n                removeWrapper: function removeWrapper(element) {\n                    var active = document.activeElement;\n\n                    if (element.parent().is(\".ui-effects-wrapper\")) {\n                        element.parent().replaceWith(element);\n\n                        // Fixes #7595 - Elements lose focus when wrapped.\n                        if (element[0] === active || $.contains(element[0], active)) {\n                            $(active).trigger(\"focus\");\n                        }\n                    }\n\n                    return element;\n                }\n            });\n        }\n\n        $.extend($.effects, {\n            version: \"1.12.1\",\n\n            define: function define(name, mode, effect) {\n                if (!effect) {\n                    effect = mode;\n                    mode = \"effect\";\n                }\n\n                $.effects.effect[name] = effect;\n                $.effects.effect[name].mode = mode;\n\n                return effect;\n            },\n\n            scaledDimensions: function scaledDimensions(element, percent, direction) {\n                if (percent === 0) {\n                    return {\n                        height: 0,\n                        width: 0,\n                        outerHeight: 0,\n                        outerWidth: 0\n                    };\n                }\n\n                var x = direction !== \"horizontal\" ? (percent || 100) / 100 : 1,\n                    y = direction !== \"vertical\" ? (percent || 100) / 100 : 1;\n\n                return {\n                    height: element.height() * y,\n                    width: element.width() * x,\n                    outerHeight: element.outerHeight() * y,\n                    outerWidth: element.outerWidth() * x\n                };\n            },\n\n            clipToBox: function clipToBox(animation) {\n                return {\n                    width: animation.clip.right - animation.clip.left,\n                    height: animation.clip.bottom - animation.clip.top,\n                    left: animation.clip.left,\n                    top: animation.clip.top\n                };\n            },\n\n            // Injects recently queued functions to be first in line (after \"inprogress\")\n            unshift: function unshift(element, queueLength, count) {\n                var queue = element.queue();\n\n                if (queueLength > 1) {\n                    queue.splice.apply(queue, [1, 0].concat(queue.splice(queueLength, count)));\n                }\n                element.dequeue();\n            },\n\n            saveStyle: function saveStyle(element) {\n                element.data(dataSpaceStyle, element[0].style.cssText);\n            },\n\n            restoreStyle: function restoreStyle(element) {\n                element[0].style.cssText = element.data(dataSpaceStyle) || \"\";\n                element.removeData(dataSpaceStyle);\n            },\n\n            mode: function mode(element, _mode) {\n                var hidden = element.is(\":hidden\");\n\n                if (_mode === \"toggle\") {\n                    _mode = hidden ? \"show\" : \"hide\";\n                }\n                if (hidden ? _mode === \"hide\" : _mode === \"show\") {\n                    _mode = \"none\";\n                }\n                return _mode;\n            },\n\n            // Translates a [top,left] array into a baseline value\n            getBaseline: function getBaseline(origin, original) {\n                var y, x;\n\n                switch (origin[0]) {\n                    case \"top\":\n                        y = 0;\n                        break;\n                    case \"middle\":\n                        y = 0.5;\n                        break;\n                    case \"bottom\":\n                        y = 1;\n                        break;\n                    default:\n                        y = origin[0] / original.height;\n                }\n\n                switch (origin[1]) {\n                    case \"left\":\n                        x = 0;\n                        break;\n                    case \"center\":\n                        x = 0.5;\n                        break;\n                    case \"right\":\n                        x = 1;\n                        break;\n                    default:\n                        x = origin[1] / original.width;\n                }\n\n                return {\n                    x: x,\n                    y: y\n                };\n            },\n\n            // Creates a placeholder element so that the original element can be made absolute\n            createPlaceholder: function createPlaceholder(element) {\n                var placeholder,\n                    cssPosition = element.css(\"position\"),\n                    position = element.position();\n\n                // Lock in margins first to account for form elements, which\n                // will change margin if you explicitly set height\n                // see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380\n                // Support: Safari\n                element.css({\n                    marginTop: element.css(\"marginTop\"),\n                    marginBottom: element.css(\"marginBottom\"),\n                    marginLeft: element.css(\"marginLeft\"),\n                    marginRight: element.css(\"marginRight\")\n                }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight());\n\n                if (/^(static|relative)/.test(cssPosition)) {\n                    cssPosition = \"absolute\";\n\n                    placeholder = $(\"<\" + element[0].nodeName + \">\").insertAfter(element).css({\n\n                        // Convert inline to inline block to account for inline elements\n                        // that turn to inline block based on content (like img)\n                        display: /^(inline|ruby)/.test(element.css(\"display\")) ? \"inline-block\" : \"block\",\n                        visibility: \"hidden\",\n\n                        // Margins need to be set to account for margin collapse\n                        marginTop: element.css(\"marginTop\"),\n                        marginBottom: element.css(\"marginBottom\"),\n                        marginLeft: element.css(\"marginLeft\"),\n                        marginRight: element.css(\"marginRight\"),\n                        \"float\": element.css(\"float\")\n                    }).outerWidth(element.outerWidth()).outerHeight(element.outerHeight()).addClass(\"ui-effects-placeholder\");\n\n                    element.data(dataSpace + \"placeholder\", placeholder);\n                }\n\n                element.css({\n                    position: cssPosition,\n                    left: position.left,\n                    top: position.top\n                });\n\n                return placeholder;\n            },\n\n            removePlaceholder: function removePlaceholder(element) {\n                var dataKey = dataSpace + \"placeholder\",\n                    placeholder = element.data(dataKey);\n\n                if (placeholder) {\n                    placeholder.remove();\n                    element.removeData(dataKey);\n                }\n            },\n\n            // Removes a placeholder if it exists and restores\n            // properties that were modified during placeholder creation\n            cleanUp: function cleanUp(element) {\n                $.effects.restoreStyle(element);\n                $.effects.removePlaceholder(element);\n            },\n\n            setTransition: function setTransition(element, list, factor, value) {\n                value = value || {};\n                $.each(list, function (i, x) {\n                    var unit = element.cssUnit(x);\n                    if (unit[0] > 0) {\n                        value[x] = unit[0] * factor + unit[1];\n                    }\n                });\n                return value;\n            }\n        });\n\n        // Return an effect options object for the given parameters:\n        function _normalizeArguments(effect, options, speed, callback) {\n\n            // Allow passing all options as the first parameter\n            if ($.isPlainObject(effect)) {\n                options = effect;\n                effect = effect.effect;\n            }\n\n            // Convert to an object\n            effect = { effect: effect };\n\n            // Catch (effect, null, ...)\n            if (options == null) {\n                options = {};\n            }\n\n            // Catch (effect, callback)\n            if ($.isFunction(options)) {\n                callback = options;\n                speed = null;\n                options = {};\n            }\n\n            // Catch (effect, speed, ?)\n            if (typeof options === \"number\" || $.fx.speeds[options]) {\n                callback = speed;\n                speed = options;\n                options = {};\n            }\n\n            // Catch (effect, options, callback)\n            if ($.isFunction(speed)) {\n                callback = speed;\n                speed = null;\n            }\n\n            // Add options to effect\n            if (options) {\n                $.extend(effect, options);\n            }\n\n            speed = speed || options.duration;\n            effect.duration = $.fx.off ? 0 : typeof speed === \"number\" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;\n\n            effect.complete = callback || options.complete;\n\n            return effect;\n        }\n\n        function standardAnimationOption(option) {\n\n            // Valid standard speeds (nothing, number, named speed)\n            if (!option || typeof option === \"number\" || $.fx.speeds[option]) {\n                return true;\n            }\n\n            // Invalid strings - treat as \"normal\" speed\n            if (typeof option === \"string\" && !$.effects.effect[option]) {\n                return true;\n            }\n\n            // Complete callback\n            if ($.isFunction(option)) {\n                return true;\n            }\n\n            // Options hash (but not naming an effect)\n            if ((typeof option === \"undefined\" ? \"undefined\" : _typeof(option)) === \"object\" && !option.effect) {\n                return true;\n            }\n\n            // Didn't match any standard API\n            return false;\n        }\n\n        $.fn.extend({\n            effect: function effect() /* effect, options, speed, callback */{\n                var args = _normalizeArguments.apply(this, arguments),\n                    effectMethod = $.effects.effect[args.effect],\n                    defaultMode = effectMethod.mode,\n                    queue = args.queue,\n                    queueName = queue || \"fx\",\n                    complete = args.complete,\n                    mode = args.mode,\n                    modes = [],\n                    prefilter = function prefilter(next) {\n                    var el = $(this),\n                        normalizedMode = $.effects.mode(el, mode) || defaultMode;\n\n                    // Sentinel for duck-punching the :animated psuedo-selector\n                    el.data(dataSpaceAnimated, true);\n\n                    // Save effect mode for later use,\n                    // we can't just call $.effects.mode again later,\n                    // as the .show() below destroys the initial state\n                    modes.push(normalizedMode);\n\n                    // See $.uiBackCompat inside of run() for removal of defaultMode in 1.13\n                    if (defaultMode && (normalizedMode === \"show\" || normalizedMode === defaultMode && normalizedMode === \"hide\")) {\n                        el.show();\n                    }\n\n                    if (!defaultMode || normalizedMode !== \"none\") {\n                        $.effects.saveStyle(el);\n                    }\n\n                    if ($.isFunction(next)) {\n                        next();\n                    }\n                };\n\n                if ($.fx.off || !effectMethod) {\n\n                    // Delegate to the original method (e.g., .show()) if possible\n                    if (mode) {\n                        return this[mode](args.duration, complete);\n                    } else {\n                        return this.each(function () {\n                            if (complete) {\n                                complete.call(this);\n                            }\n                        });\n                    }\n                }\n\n                function run(next) {\n                    var elem = $(this);\n\n                    function cleanup() {\n                        elem.removeData(dataSpaceAnimated);\n\n                        $.effects.cleanUp(elem);\n\n                        if (args.mode === \"hide\") {\n                            elem.hide();\n                        }\n\n                        done();\n                    }\n\n                    function done() {\n                        if ($.isFunction(complete)) {\n                            complete.call(elem[0]);\n                        }\n\n                        if ($.isFunction(next)) {\n                            next();\n                        }\n                    }\n\n                    // Override mode option on a per element basis,\n                    // as toggle can be either show or hide depending on element state\n                    args.mode = modes.shift();\n\n                    if ($.uiBackCompat !== false && !defaultMode) {\n                        if (elem.is(\":hidden\") ? mode === \"hide\" : mode === \"show\") {\n\n                            // Call the core method to track \"olddisplay\" properly\n                            elem[mode]();\n                            done();\n                        } else {\n                            effectMethod.call(elem[0], args, done);\n                        }\n                    } else {\n                        if (args.mode === \"none\") {\n\n                            // Call the core method to track \"olddisplay\" properly\n                            elem[mode]();\n                            done();\n                        } else {\n                            effectMethod.call(elem[0], args, cleanup);\n                        }\n                    }\n                }\n\n                // Run prefilter on all elements first to ensure that\n                // any showing or hiding happens before placeholder creation,\n                // which ensures that any layout changes are correctly captured.\n                return queue === false ? this.each(prefilter).each(run) : this.queue(queueName, prefilter).queue(queueName, run);\n            },\n\n            show: function (orig) {\n                return function (option) {\n                    if (standardAnimationOption(option)) {\n                        return orig.apply(this, arguments);\n                    } else {\n                        var args = _normalizeArguments.apply(this, arguments);\n                        args.mode = \"show\";\n                        return this.effect.call(this, args);\n                    }\n                };\n            }($.fn.show),\n\n            hide: function (orig) {\n                return function (option) {\n                    if (standardAnimationOption(option)) {\n                        return orig.apply(this, arguments);\n                    } else {\n                        var args = _normalizeArguments.apply(this, arguments);\n                        args.mode = \"hide\";\n                        return this.effect.call(this, args);\n                    }\n                };\n            }($.fn.hide),\n\n            toggle: function (orig) {\n                return function (option) {\n                    if (standardAnimationOption(option) || typeof option === \"boolean\") {\n                        return orig.apply(this, arguments);\n                    } else {\n                        var args = _normalizeArguments.apply(this, arguments);\n                        args.mode = \"toggle\";\n                        return this.effect.call(this, args);\n                    }\n                };\n            }($.fn.toggle),\n\n            cssUnit: function cssUnit(key) {\n                var style = this.css(key),\n                    val = [];\n\n                $.each([\"em\", \"px\", \"%\", \"pt\"], function (i, unit) {\n                    if (style.indexOf(unit) > 0) {\n                        val = [parseFloat(style), unit];\n                    }\n                });\n                return val;\n            },\n\n            cssClip: function cssClip(clipObj) {\n                if (clipObj) {\n                    return this.css(\"clip\", \"rect(\" + clipObj.top + \"px \" + clipObj.right + \"px \" + clipObj.bottom + \"px \" + clipObj.left + \"px)\");\n                }\n                return parseClip(this.css(\"clip\"), this);\n            },\n\n            transfer: function transfer(options, done) {\n                var element = $(this),\n                    target = $(options.to),\n                    targetFixed = target.css(\"position\") === \"fixed\",\n                    body = $(\"body\"),\n                    fixTop = targetFixed ? body.scrollTop() : 0,\n                    fixLeft = targetFixed ? body.scrollLeft() : 0,\n                    endPosition = target.offset(),\n                    animation = {\n                    top: endPosition.top - fixTop,\n                    left: endPosition.left - fixLeft,\n                    height: target.innerHeight(),\n                    width: target.innerWidth()\n                },\n                    startPosition = element.offset(),\n                    transfer = $(\"<div class='ui-effects-transfer'></div>\").appendTo(\"body\").addClass(options.className).css({\n                    top: startPosition.top - fixTop,\n                    left: startPosition.left - fixLeft,\n                    height: element.innerHeight(),\n                    width: element.innerWidth(),\n                    position: targetFixed ? \"fixed\" : \"absolute\"\n                }).animate(animation, options.duration, options.easing, function () {\n                    transfer.remove();\n                    if ($.isFunction(done)) {\n                        done();\n                    }\n                });\n            }\n        });\n\n        function parseClip(str, element) {\n            var outerWidth = element.outerWidth(),\n                outerHeight = element.outerHeight(),\n                clipRegex = /^rect\\((-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto),?\\s*(-?\\d*\\.?\\d*px|-?\\d+%|auto)\\)$/,\n                values = clipRegex.exec(str) || [\"\", 0, outerWidth, outerHeight, 0];\n\n            return {\n                top: parseFloat(values[1]) || 0,\n                right: values[2] === \"auto\" ? outerWidth : parseFloat(values[2]),\n                bottom: values[3] === \"auto\" ? outerHeight : parseFloat(values[3]),\n                left: parseFloat(values[4]) || 0\n            };\n        }\n\n        $.fx.step.clip = function (fx) {\n            if (!fx.clipInit) {\n                fx.start = $(fx.elem).cssClip();\n                if (typeof fx.end === \"string\") {\n                    fx.end = parseClip(fx.end, fx.elem);\n                }\n                fx.clipInit = true;\n            }\n\n            $(fx.elem).cssClip({\n                top: fx.pos * (fx.end.top - fx.start.top) + fx.start.top,\n                right: fx.pos * (fx.end.right - fx.start.right) + fx.start.right,\n                bottom: fx.pos * (fx.end.bottom - fx.start.bottom) + fx.start.bottom,\n                left: fx.pos * (fx.end.left - fx.start.left) + fx.start.left\n            });\n        };\n    })();\n\n    /******************************************************************************/\n    /*********************************** EASING ***********************************/\n    /******************************************************************************/\n\n    (function () {\n\n        // Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\n        var baseEasings = {};\n\n        $.each([\"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Expo\"], function (i, name) {\n            baseEasings[name] = function (p) {\n                return Math.pow(p, i + 2);\n            };\n        });\n\n        $.extend(baseEasings, {\n            Sine: function Sine(p) {\n                return 1 - Math.cos(p * Math.PI / 2);\n            },\n            Circ: function Circ(p) {\n                return 1 - Math.sqrt(1 - p * p);\n            },\n            Elastic: function Elastic(p) {\n                return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);\n            },\n            Back: function Back(p) {\n                return p * p * (3 * p - 2);\n            },\n            Bounce: function Bounce(p) {\n                var pow2,\n                    bounce = 4;\n\n                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}\n                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);\n            }\n        });\n\n        $.each(baseEasings, function (name, easeIn) {\n            $.easing[\"easeIn\" + name] = easeIn;\n            $.easing[\"easeOut\" + name] = function (p) {\n                return 1 - easeIn(1 - p);\n            };\n            $.easing[\"easeInOut\" + name] = function (p) {\n                return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;\n            };\n        });\n    })();\n\n    var effect = $.effects;\n\n    /*!\n     * jQuery UI Effects Blind 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Blind Effect\n    //>>group: Effects\n    //>>description: Blinds the element.\n    //>>docs: http://api.jqueryui.com/blind-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectBlind = $.effects.define(\"blind\", \"hide\", function (options, done) {\n        var map = {\n            up: [\"bottom\", \"top\"],\n            vertical: [\"bottom\", \"top\"],\n            down: [\"top\", \"bottom\"],\n            left: [\"right\", \"left\"],\n            horizontal: [\"right\", \"left\"],\n            right: [\"left\", \"right\"]\n        },\n            element = $(this),\n            direction = options.direction || \"up\",\n            start = element.cssClip(),\n            animate = { clip: $.extend({}, start) },\n            placeholder = $.effects.createPlaceholder(element);\n\n        animate.clip[map[direction][0]] = animate.clip[map[direction][1]];\n\n        if (options.mode === \"show\") {\n            element.cssClip(animate.clip);\n            if (placeholder) {\n                placeholder.css($.effects.clipToBox(animate));\n            }\n\n            animate.clip = start;\n        }\n\n        if (placeholder) {\n            placeholder.animate($.effects.clipToBox(animate), options.duration, options.easing);\n        }\n\n        element.animate(animate, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: done\n        });\n    });\n\n    /*!\n     * jQuery UI Effects Bounce 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Bounce Effect\n    //>>group: Effects\n    //>>description: Bounces an element horizontally or vertically n times.\n    //>>docs: http://api.jqueryui.com/bounce-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectBounce = $.effects.define(\"bounce\", function (options, done) {\n        var upAnim,\n            downAnim,\n            refValue,\n            element = $(this),\n\n\n        // Defaults:\n        mode = options.mode,\n            hide = mode === \"hide\",\n            show = mode === \"show\",\n            direction = options.direction || \"up\",\n            distance = options.distance,\n            times = options.times || 5,\n\n\n        // Number of internal animations\n        anims = times * 2 + (show || hide ? 1 : 0),\n            speed = options.duration / anims,\n            easing = options.easing,\n\n\n        // Utility:\n        ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n            motion = direction === \"up\" || direction === \"left\",\n            i = 0,\n            queuelen = element.queue().length;\n\n        $.effects.createPlaceholder(element);\n\n        refValue = element.css(ref);\n\n        // Default distance for the BIGGEST bounce is the outer Distance / 3\n        if (!distance) {\n            distance = element[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"]() / 3;\n        }\n\n        if (show) {\n            downAnim = { opacity: 1 };\n            downAnim[ref] = refValue;\n\n            // If we are showing, force opacity 0 and set the initial position\n            // then do the \"first\" animation\n            element.css(\"opacity\", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);\n        }\n\n        // Start at the smallest distance if we are hiding\n        if (hide) {\n            distance = distance / Math.pow(2, times - 1);\n        }\n\n        downAnim = {};\n        downAnim[ref] = refValue;\n\n        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\n        for (; i < times; i++) {\n            upAnim = {};\n            upAnim[ref] = (motion ? \"-=\" : \"+=\") + distance;\n\n            element.animate(upAnim, speed, easing).animate(downAnim, speed, easing);\n\n            distance = hide ? distance * 2 : distance / 2;\n        }\n\n        // Last Bounce when Hiding\n        if (hide) {\n            upAnim = { opacity: 0 };\n            upAnim[ref] = (motion ? \"-=\" : \"+=\") + distance;\n\n            element.animate(upAnim, speed, easing);\n        }\n\n        element.queue(done);\n\n        $.effects.unshift(element, queuelen, anims + 1);\n    });\n\n    /*!\n     * jQuery UI Effects Clip 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Clip Effect\n    //>>group: Effects\n    //>>description: Clips the element on and off like an old TV.\n    //>>docs: http://api.jqueryui.com/clip-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectClip = $.effects.define(\"clip\", \"hide\", function (options, done) {\n        var start,\n            animate = {},\n            element = $(this),\n            direction = options.direction || \"vertical\",\n            both = direction === \"both\",\n            horizontal = both || direction === \"horizontal\",\n            vertical = both || direction === \"vertical\";\n\n        start = element.cssClip();\n        animate.clip = {\n            top: vertical ? (start.bottom - start.top) / 2 : start.top,\n            right: horizontal ? (start.right - start.left) / 2 : start.right,\n            bottom: vertical ? (start.bottom - start.top) / 2 : start.bottom,\n            left: horizontal ? (start.right - start.left) / 2 : start.left\n        };\n\n        $.effects.createPlaceholder(element);\n\n        if (options.mode === \"show\") {\n            element.cssClip(animate.clip);\n            animate.clip = start;\n        }\n\n        element.animate(animate, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: done\n        });\n    });\n\n    /*!\n     * jQuery UI Effects Drop 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Drop Effect\n    //>>group: Effects\n    //>>description: Moves an element in one direction and hides it at the same time.\n    //>>docs: http://api.jqueryui.com/drop-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectDrop = $.effects.define(\"drop\", \"hide\", function (options, done) {\n\n        var distance,\n            element = $(this),\n            mode = options.mode,\n            show = mode === \"show\",\n            direction = options.direction || \"left\",\n            ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n            motion = direction === \"up\" || direction === \"left\" ? \"-=\" : \"+=\",\n            oppositeMotion = motion === \"+=\" ? \"-=\" : \"+=\",\n            animation = {\n            opacity: 0\n        };\n\n        $.effects.createPlaceholder(element);\n\n        distance = options.distance || element[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"](true) / 2;\n\n        animation[ref] = motion + distance;\n\n        if (show) {\n            element.css(animation);\n\n            animation[ref] = oppositeMotion + distance;\n            animation.opacity = 1;\n        }\n\n        // Animate\n        element.animate(animation, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: done\n        });\n    });\n\n    /*!\n     * jQuery UI Effects Explode 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Explode Effect\n    //>>group: Effects\n    // jscs:disable maximumLineLength\n    //>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.\n    // jscs:enable maximumLineLength\n    //>>docs: http://api.jqueryui.com/explode-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectExplode = $.effects.define(\"explode\", \"hide\", function (options, done) {\n\n        var i,\n            j,\n            left,\n            top,\n            mx,\n            my,\n            rows = options.pieces ? Math.round(Math.sqrt(options.pieces)) : 3,\n            cells = rows,\n            element = $(this),\n            mode = options.mode,\n            show = mode === \"show\",\n\n\n        // Show and then visibility:hidden the element before calculating offset\n        offset = element.show().css(\"visibility\", \"hidden\").offset(),\n\n\n        // Width and height of a piece\n        width = Math.ceil(element.outerWidth() / cells),\n            height = Math.ceil(element.outerHeight() / rows),\n            pieces = [];\n\n        // Children animate complete:\n        function childComplete() {\n            pieces.push(this);\n            if (pieces.length === rows * cells) {\n                animComplete();\n            }\n        }\n\n        // Clone the element for each row and cell.\n        for (i = 0; i < rows; i++) {\n            // ===>\n            top = offset.top + i * height;\n            my = i - (rows - 1) / 2;\n\n            for (j = 0; j < cells; j++) {\n                // |||\n                left = offset.left + j * width;\n                mx = j - (cells - 1) / 2;\n\n                // Create a clone of the now hidden main element that will be absolute positioned\n                // within a wrapper div off the -left and -top equal to size of our pieces\n                element.clone().appendTo(\"body\").wrap(\"<div></div>\").css({\n                    position: \"absolute\",\n                    visibility: \"visible\",\n                    left: -j * width,\n                    top: -i * height\n                })\n\n                // Select the wrapper - make it overflow: hidden and absolute positioned based on\n                // where the original was located +left and +top equal to the size of pieces\n                .parent().addClass(\"ui-effects-explode\").css({\n                    position: \"absolute\",\n                    overflow: \"hidden\",\n                    width: width,\n                    height: height,\n                    left: left + (show ? mx * width : 0),\n                    top: top + (show ? my * height : 0),\n                    opacity: show ? 0 : 1\n                }).animate({\n                    left: left + (show ? 0 : mx * width),\n                    top: top + (show ? 0 : my * height),\n                    opacity: show ? 1 : 0\n                }, options.duration || 500, options.easing, childComplete);\n            }\n        }\n\n        function animComplete() {\n            element.css({\n                visibility: \"visible\"\n            });\n            $(pieces).remove();\n            done();\n        }\n    });\n\n    /*!\n     * jQuery UI Effects Fade 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Fade Effect\n    //>>group: Effects\n    //>>description: Fades the element.\n    //>>docs: http://api.jqueryui.com/fade-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectFade = $.effects.define(\"fade\", \"toggle\", function (options, done) {\n        var show = options.mode === \"show\";\n\n        $(this).css(\"opacity\", show ? 0 : 1).animate({\n            opacity: show ? 1 : 0\n        }, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: done\n        });\n    });\n\n    /*!\n     * jQuery UI Effects Fold 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Fold Effect\n    //>>group: Effects\n    //>>description: Folds an element first horizontally and then vertically.\n    //>>docs: http://api.jqueryui.com/fold-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectFold = $.effects.define(\"fold\", \"hide\", function (options, done) {\n\n        // Create element\n        var element = $(this),\n            mode = options.mode,\n            show = mode === \"show\",\n            hide = mode === \"hide\",\n            size = options.size || 15,\n            percent = /([0-9]+)%/.exec(size),\n            horizFirst = !!options.horizFirst,\n            ref = horizFirst ? [\"right\", \"bottom\"] : [\"bottom\", \"right\"],\n            duration = options.duration / 2,\n            placeholder = $.effects.createPlaceholder(element),\n            start = element.cssClip(),\n            animation1 = { clip: $.extend({}, start) },\n            animation2 = { clip: $.extend({}, start) },\n            distance = [start[ref[0]], start[ref[1]]],\n            queuelen = element.queue().length;\n\n        if (percent) {\n            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];\n        }\n        animation1.clip[ref[0]] = size;\n        animation2.clip[ref[0]] = size;\n        animation2.clip[ref[1]] = 0;\n\n        if (show) {\n            element.cssClip(animation2.clip);\n            if (placeholder) {\n                placeholder.css($.effects.clipToBox(animation2));\n            }\n\n            animation2.clip = start;\n        }\n\n        // Animate\n        element.queue(function (next) {\n            if (placeholder) {\n                placeholder.animate($.effects.clipToBox(animation1), duration, options.easing).animate($.effects.clipToBox(animation2), duration, options.easing);\n            }\n\n            next();\n        }).animate(animation1, duration, options.easing).animate(animation2, duration, options.easing).queue(done);\n\n        $.effects.unshift(element, queuelen, 4);\n    });\n\n    /*!\n     * jQuery UI Effects Highlight 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Highlight Effect\n    //>>group: Effects\n    //>>description: Highlights the background of an element in a defined color for a custom duration.\n    //>>docs: http://api.jqueryui.com/highlight-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectHighlight = $.effects.define(\"highlight\", \"show\", function (options, done) {\n        var element = $(this),\n            animation = {\n            backgroundColor: element.css(\"backgroundColor\")\n        };\n\n        if (options.mode === \"hide\") {\n            animation.opacity = 0;\n        }\n\n        $.effects.saveStyle(element);\n\n        element.css({\n            backgroundImage: \"none\",\n            backgroundColor: options.color || \"#ffff99\"\n        }).animate(animation, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: done\n        });\n    });\n\n    /*!\n     * jQuery UI Effects Size 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Size Effect\n    //>>group: Effects\n    //>>description: Resize an element to a specified width and height.\n    //>>docs: http://api.jqueryui.com/size-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectSize = $.effects.define(\"size\", function (options, done) {\n\n        // Create element\n        var baseline,\n            factor,\n            temp,\n            element = $(this),\n\n\n        // Copy for children\n        cProps = [\"fontSize\"],\n            vProps = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"],\n            hProps = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"],\n\n\n        // Set options\n        mode = options.mode,\n            restore = mode !== \"effect\",\n            scale = options.scale || \"both\",\n            origin = options.origin || [\"middle\", \"center\"],\n            position = element.css(\"position\"),\n            pos = element.position(),\n            original = $.effects.scaledDimensions(element),\n            from = options.from || original,\n            to = options.to || $.effects.scaledDimensions(element, 0);\n\n        $.effects.createPlaceholder(element);\n\n        if (mode === \"show\") {\n            temp = from;\n            from = to;\n            to = temp;\n        }\n\n        // Set scaling factor\n        factor = {\n            from: {\n                y: from.height / original.height,\n                x: from.width / original.width\n            },\n            to: {\n                y: to.height / original.height,\n                x: to.width / original.width\n            }\n        };\n\n        // Scale the css box\n        if (scale === \"box\" || scale === \"both\") {\n\n            // Vertical props scaling\n            if (factor.from.y !== factor.to.y) {\n                from = $.effects.setTransition(element, vProps, factor.from.y, from);\n                to = $.effects.setTransition(element, vProps, factor.to.y, to);\n            }\n\n            // Horizontal props scaling\n            if (factor.from.x !== factor.to.x) {\n                from = $.effects.setTransition(element, hProps, factor.from.x, from);\n                to = $.effects.setTransition(element, hProps, factor.to.x, to);\n            }\n        }\n\n        // Scale the content\n        if (scale === \"content\" || scale === \"both\") {\n\n            // Vertical props scaling\n            if (factor.from.y !== factor.to.y) {\n                from = $.effects.setTransition(element, cProps, factor.from.y, from);\n                to = $.effects.setTransition(element, cProps, factor.to.y, to);\n            }\n        }\n\n        // Adjust the position properties based on the provided origin points\n        if (origin) {\n            baseline = $.effects.getBaseline(origin, original);\n            from.top = (original.outerHeight - from.outerHeight) * baseline.y + pos.top;\n            from.left = (original.outerWidth - from.outerWidth) * baseline.x + pos.left;\n            to.top = (original.outerHeight - to.outerHeight) * baseline.y + pos.top;\n            to.left = (original.outerWidth - to.outerWidth) * baseline.x + pos.left;\n        }\n        element.css(from);\n\n        // Animate the children if desired\n        if (scale === \"content\" || scale === \"both\") {\n\n            vProps = vProps.concat([\"marginTop\", \"marginBottom\"]).concat(cProps);\n            hProps = hProps.concat([\"marginLeft\", \"marginRight\"]);\n\n            // Only animate children with width attributes specified\n            // TODO: is this right? should we include anything with css width specified as well\n            element.find(\"*[width]\").each(function () {\n                var child = $(this),\n                    childOriginal = $.effects.scaledDimensions(child),\n                    childFrom = {\n                    height: childOriginal.height * factor.from.y,\n                    width: childOriginal.width * factor.from.x,\n                    outerHeight: childOriginal.outerHeight * factor.from.y,\n                    outerWidth: childOriginal.outerWidth * factor.from.x\n                },\n                    childTo = {\n                    height: childOriginal.height * factor.to.y,\n                    width: childOriginal.width * factor.to.x,\n                    outerHeight: childOriginal.height * factor.to.y,\n                    outerWidth: childOriginal.width * factor.to.x\n                };\n\n                // Vertical props scaling\n                if (factor.from.y !== factor.to.y) {\n                    childFrom = $.effects.setTransition(child, vProps, factor.from.y, childFrom);\n                    childTo = $.effects.setTransition(child, vProps, factor.to.y, childTo);\n                }\n\n                // Horizontal props scaling\n                if (factor.from.x !== factor.to.x) {\n                    childFrom = $.effects.setTransition(child, hProps, factor.from.x, childFrom);\n                    childTo = $.effects.setTransition(child, hProps, factor.to.x, childTo);\n                }\n\n                if (restore) {\n                    $.effects.saveStyle(child);\n                }\n\n                // Animate children\n                child.css(childFrom);\n                child.animate(childTo, options.duration, options.easing, function () {\n\n                    // Restore children\n                    if (restore) {\n                        $.effects.restoreStyle(child);\n                    }\n                });\n            });\n        }\n\n        // Animate\n        element.animate(to, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: function complete() {\n\n                var offset = element.offset();\n\n                if (to.opacity === 0) {\n                    element.css(\"opacity\", from.opacity);\n                }\n\n                if (!restore) {\n                    element.css(\"position\", position === \"static\" ? \"relative\" : position).offset(offset);\n\n                    // Need to save style here so that automatic style restoration\n                    // doesn't restore to the original styles from before the animation.\n                    $.effects.saveStyle(element);\n                }\n\n                done();\n            }\n        });\n    });\n\n    /*!\n     * jQuery UI Effects Scale 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Scale Effect\n    //>>group: Effects\n    //>>description: Grows or shrinks an element and its content.\n    //>>docs: http://api.jqueryui.com/scale-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectScale = $.effects.define(\"scale\", function (options, done) {\n\n        // Create element\n        var el = $(this),\n            mode = options.mode,\n            percent = parseInt(options.percent, 10) || (parseInt(options.percent, 10) === 0 ? 0 : mode !== \"effect\" ? 0 : 100),\n            newOptions = $.extend(true, {\n            from: $.effects.scaledDimensions(el),\n            to: $.effects.scaledDimensions(el, percent, options.direction || \"both\"),\n            origin: options.origin || [\"middle\", \"center\"]\n        }, options);\n\n        // Fade option to support puff\n        if (options.fade) {\n            newOptions.from.opacity = 1;\n            newOptions.to.opacity = 0;\n        }\n\n        $.effects.effect.size.call(this, newOptions, done);\n    });\n\n    /*!\n     * jQuery UI Effects Puff 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Puff Effect\n    //>>group: Effects\n    //>>description: Creates a puff effect by scaling the element up and hiding it at the same time.\n    //>>docs: http://api.jqueryui.com/puff-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectPuff = $.effects.define(\"puff\", \"hide\", function (options, done) {\n        var newOptions = $.extend(true, {}, options, {\n            fade: true,\n            percent: parseInt(options.percent, 10) || 150\n        });\n\n        $.effects.effect.scale.call(this, newOptions, done);\n    });\n\n    /*!\n     * jQuery UI Effects Pulsate 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Pulsate Effect\n    //>>group: Effects\n    //>>description: Pulsates an element n times by changing the opacity to zero and back.\n    //>>docs: http://api.jqueryui.com/pulsate-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectPulsate = $.effects.define(\"pulsate\", \"show\", function (options, done) {\n        var element = $(this),\n            mode = options.mode,\n            show = mode === \"show\",\n            hide = mode === \"hide\",\n            showhide = show || hide,\n\n\n        // Showing or hiding leaves off the \"last\" animation\n        anims = (options.times || 5) * 2 + (showhide ? 1 : 0),\n            duration = options.duration / anims,\n            animateTo = 0,\n            i = 1,\n            queuelen = element.queue().length;\n\n        if (show || !element.is(\":visible\")) {\n            element.css(\"opacity\", 0).show();\n            animateTo = 1;\n        }\n\n        // Anims - 1 opacity \"toggles\"\n        for (; i < anims; i++) {\n            element.animate({ opacity: animateTo }, duration, options.easing);\n            animateTo = 1 - animateTo;\n        }\n\n        element.animate({ opacity: animateTo }, duration, options.easing);\n\n        element.queue(done);\n\n        $.effects.unshift(element, queuelen, anims + 1);\n    });\n\n    /*!\n     * jQuery UI Effects Shake 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Shake Effect\n    //>>group: Effects\n    //>>description: Shakes an element horizontally or vertically n times.\n    //>>docs: http://api.jqueryui.com/shake-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectShake = $.effects.define(\"shake\", function (options, done) {\n\n        var i = 1,\n            element = $(this),\n            direction = options.direction || \"left\",\n            distance = options.distance || 20,\n            times = options.times || 3,\n            anims = times * 2 + 1,\n            speed = Math.round(options.duration / anims),\n            ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n            positiveMotion = direction === \"up\" || direction === \"left\",\n            animation = {},\n            animation1 = {},\n            animation2 = {},\n            queuelen = element.queue().length;\n\n        $.effects.createPlaceholder(element);\n\n        // Animation\n        animation[ref] = (positiveMotion ? \"-=\" : \"+=\") + distance;\n        animation1[ref] = (positiveMotion ? \"+=\" : \"-=\") + distance * 2;\n        animation2[ref] = (positiveMotion ? \"-=\" : \"+=\") + distance * 2;\n\n        // Animate\n        element.animate(animation, speed, options.easing);\n\n        // Shakes\n        for (; i < times; i++) {\n            element.animate(animation1, speed, options.easing).animate(animation2, speed, options.easing);\n        }\n\n        element.animate(animation1, speed, options.easing).animate(animation, speed / 2, options.easing).queue(done);\n\n        $.effects.unshift(element, queuelen, anims + 1);\n    });\n\n    /*!\n     * jQuery UI Effects Slide 1.12.1\n     * http://jqueryui.com\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license.\n     * http://jquery.org/license\n     */\n\n    //>>label: Slide Effect\n    //>>group: Effects\n    //>>description: Slides an element in and out of the viewport.\n    //>>docs: http://api.jqueryui.com/slide-effect/\n    //>>demos: http://jqueryui.com/effect/\n\n\n    var effectsEffectSlide = $.effects.define(\"slide\", \"show\", function (options, done) {\n        var startClip,\n            startRef,\n            element = $(this),\n            map = {\n            up: [\"bottom\", \"top\"],\n            down: [\"top\", \"bottom\"],\n            left: [\"right\", \"left\"],\n            right: [\"left\", \"right\"]\n        },\n            mode = options.mode,\n            direction = options.direction || \"left\",\n            ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n            positiveMotion = direction === \"up\" || direction === \"left\",\n            distance = options.distance || element[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"](true),\n            animation = {};\n\n        $.effects.createPlaceholder(element);\n\n        startClip = element.cssClip();\n        startRef = element.position()[ref];\n\n        // Define hide animation\n        animation[ref] = (positiveMotion ? -1 : 1) * distance + startRef;\n        animation.clip = element.cssClip();\n        animation.clip[map[direction][1]] = animation.clip[map[direction][0]];\n\n        // Reverse the animation if we're showing\n        if (mode === \"show\") {\n            element.cssClip(animation.clip);\n            element.css(ref, animation[ref]);\n            animation.clip = startClip;\n            animation[ref] = startRef;\n        }\n\n        // Actually animate\n        element.animate(animation, {\n            queue: false,\n            duration: options.duration,\n            easing: options.easing,\n            complete: done\n        });\n    });\n})(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kZXYvalF1ZXJ5LnBpY3R1cmVzLnZpZXdzLmpzPzg0MTEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCAkICl7XG5cbiAgICAkLmZuLnZpZXdzUGljdHVyZXMgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgT3B0aW9ucyBwbHVnaW4uLlxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgY29uZmlnPSB7XG4gICAgICAgICAgICBcImJnQ29sb3JcIiAgICAgICA6IFwiI0JBQkFCQVwiLFxuICAgICAgICAgICAgXCJzcGVlZEltZ1wiICAgICAgOiA0MDAsXG4gICAgICAgICAgICBcImVmZmVjdEltZ1wiICAgICA6IFwic2xpZGVcIixcbiAgICAgICAgICAgIFwibmF2Q29sb3JcIiAgICAgIDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICBcImNhbGxiYWNrXCIgICAgICA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhcmFtcyA9ICQuZXh0ZW5kKGNvbmZpZywgb3B0aW9ucyk7XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgICAgICBmdW5jdGlvbiBtYWtlaWQoKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgcG9zc2libGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKVxuICAgICAgICAgICAgdGV4dCArPSBwb3NzaWJsZS5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9zc2libGUubGVuZ3RoKSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXFJZCA9IG1ha2VpZCgpO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICBBZGQgYmxvY2sgc2xpZGUgcGljdHVyZVxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgYmxvY2tfcGljdHVyZSA9XG4gICAgICAgICAgICAnPGRpdiBpZD1cIicrdW5pcUlkKydcIiBjbGFzcz1cInNjcmVlbl9yb290XCI+JytcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInNjcmVlbl9uYXZfbGVmdFwiIHN0eWxlPVwiY29sb3I6JytwYXJhbXMubmF2Q29sb3IrJ1wiPjwvZGl2PicrXG4gICAgICAgICAgICAgICAgJzx1bCBjbGFzcz1cInNjcmVlbl9ibG9ja1wiPjwvdWw+JytcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInNjcmVlbl9uYXZfcmlnaHRcIiBzdHlsZT1cImNvbG9yOicrcGFyYW1zLm5hdkNvbG9yKydcIj48L2Rpdj4nK1xuICAgICAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAgICAgJCgnYm9keScpLmFwcGVuZChibG9ja19waWN0dXJlKTtcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgQWRkIGJhY2tncm91bmQuLlxuICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICB2YXIgYmxvY2tfYmFja2dyb3VuZCA9ICc8ZGl2IGNsYXNzPVwic2NyZWVuX2JnXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrcGFyYW1zLmJnQ29sb3IrJ1wiPjwvZGl2Pic7XG4gICAgICAgICQoXCIjXCIrdW5pcUlkKS5hcHBlbmQoYmxvY2tfYmFja2dyb3VuZCk7XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgICAgICByZXR1cm4gdGhpcy5maW5kKCdpbWcnKS5lYWNoKGZ1bmN0aW9uKGksIGUpe1xuXG4gICAgICAgICAgICB2YXIgZCA9IGkrMTtcblxuICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdkYXRhLXNjcmVlbicsIGQpXG5cbiAgICAgICAgICAgIHZhciBzcmMgPSAkKGUpLmF0dHIoJ3NyYycpO1xuICAgICAgICAgICAgdmFyIGlkID0gaSsxO1xuXG4gICAgICAgICAgICAkKFwiI1wiK3VuaXFJZCkuZmluZCgndWwuc2NyZWVuX2Jsb2NrJykuYXBwZW5kKCc8bGkgZGF0YS1zY3JlZW49XCInK2QrJ1wiIGlkPVwic2NyZWVuXycraWQrJ1wiIGNsYXNzPVwic2NyZWVuX2xpc3RcIj48aW1nIGNsYXNzPVwic2NyZWVuX2ltZ1wiIHNyYz1cIicrc3JjKydcIiAvPjwvbGk+Jyk7XG5cbiAgICAgICAgICAgICQodGhpcykub2ZmKCdjbGljaycpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9ICQodGhpcykuYXR0cignZGF0YS1zY3JlZW4nKTtcblxuICAgICAgICAgICAgICAgICQoJy5zY3JlZW5fYmcnKS5mYWRlSW4oMzAwLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBwYXJhbXMuZWZmZWN0SW1nID09PSBcInNsaWRlXCIgKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnNjcmVlbl9yb290JykuZmFkZUluKDMwMCwgZnVuY3Rpb24oKXsgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytjKydcIl0nKS5zbGlkZURvd24ocGFyYW1zLnNwZWVkSW1nKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICggcGFyYW1zLmVmZmVjdEltZyA9PT0gXCJmYWRlXCIgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJy5zY3JlZW5fcm9vdCcpLmZhZGVJbigzMDAsIGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrYysnXCJdJykuZmFkZUluKHBhcmFtcy5zcGVlZEltZyk7IH0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICAgICAgICAgICAgVUkgRWZmZWN0XG4gICAgICAgICAgICAgICAgICAgICoqKioqKioqKioqKioqKiovXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBwYXJhbXMuZWZmZWN0SW1nID09PSBcImJvdW5jZVwiICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcuc2NyZWVuX3Jvb3QnKS5mYWRlSW4oMzAwLCBmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGlbZGF0YS1zY3JlZW49XCInK2MrJ1wiXScpLmZhZGVJbihwYXJhbXMuc3BlZWRJbWcpLmVmZmVjdCgnYm91bmNlJyk7IH0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnNjcmVlbl9yb290JykuZmFkZUluKDMwMCwgZnVuY3Rpb24oKXsgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytjKydcIl0nKS5zbGlkZURvd24ocGFyYW1zLnNwZWVkSW1nKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAkKFwiI1wiK3VuaXFJZCkub2ZmKCdjbGljaycsICcuc2NyZWVuX2JnJykub24oJ2NsaWNrJywgJy5zY3JlZW5fYmcnLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpJykuZmFkZU91dCgzMDAsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICQoJy5zY3JlZW5fcm9vdCcpLmZhZGVPdXQoMzAwLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLnNjcmVlbl9iZycpLmZhZGVPdXQoMzAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJ2xpLnNjcmVlbl9saXN0JykuaGlkZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgJChcIiNcIit1bmlxSWQpLm9mZignY2xpY2snLCAnLnNjcmVlbl9uYXZfcmlnaHQnKS5vbignY2xpY2snLCAnLnNjcmVlbl9uYXZfcmlnaHQnLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgdmFyIGcgPSAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6dmlzaWJsZScpLmF0dHIoJ2RhdGEtc2NyZWVuJylcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHBhcnNlSW50KGcpKzE7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVPdXQgPSBwYXJhbXMuc3BlZWRJbWcgKyAxMDA7XG5cbiAgICAgICAgICAgICAgICBpZiggcGFyYW1zLmVmZmVjdEltZyA9PT0gXCJzbGlkZVwiICl7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytnKydcIl0nKS5zbGlkZVVwKHBhcmFtcy5zcGVlZEltZylcblxuICAgICAgICAgICAgICAgICAgICBpZiggbyA8PSAkKCdsaS5zY3JlZW5fbGlzdCcpLmxlbmd0aCB8fCBvID09IE5hTiApe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGlbZGF0YS1zY3JlZW49XCInK28rJ1wiXScpLnNsaWRlRG93bihwYXJhbXMuc3BlZWRJbWcpOyB9LHRpbWVPdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpOmZpcnN0Jykuc2xpZGVEb3duKHBhcmFtcy5zcGVlZEltZyk7IH0sdGltZU91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggcGFyYW1zLmVmZmVjdEltZyA9PT0gXCJmYWRlXCIgKXtcblxuICAgICAgICAgICAgICAgICAgICAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGlbZGF0YS1zY3JlZW49XCInK2crJ1wiXScpLmZhZGVPdXQocGFyYW1zLnNwZWVkSW1nKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBvIDw9ICQoJ2xpLnNjcmVlbl9saXN0JykubGVuZ3RoIHx8IG8gPT0gTmFOICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrbysnXCJdJykuZmFkZUluKHBhcmFtcy5zcGVlZEltZyk7IH0sdGltZU91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6Zmlyc3QnKS5mYWRlSW4ocGFyYW1zLnNwZWVkSW1nKTsgfSx0aW1lT3V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAgICAgICAgVUkgRWZmZWN0XG4gICAgICAgICAgICAgICAgKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggcGFyYW1zLmVmZmVjdEltZyA9PT0gXCJib3VuY2VcIiApe1xuXG4gICAgICAgICAgICAgICAgICAgICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrZysnXCJdJykuZmFkZU91dChwYXJhbXMuc3BlZWRJbWcpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIG8gPD0gJCgnbGkuc2NyZWVuX2xpc3QnKS5sZW5ndGggfHwgbyA9PSBOYU4gKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytvKydcIl0nKS5mYWRlSW4ocGFyYW1zLnNwZWVkSW1nKS5lZmZlY3QoJ2JvdW5jZScpOyB9LHRpbWVPdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpOmZpcnN0JykuZmFkZUluKHBhcmFtcy5zcGVlZEltZykuZWZmZWN0KCdib3VuY2UnKTsgfSx0aW1lT3V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxzZXtcblxuICAgICAgICAgICAgICAgICAgICAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGlbZGF0YS1zY3JlZW49XCInK2crJ1wiXScpLnNsaWRlVXAocGFyYW1zLnNwZWVkSW1nKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBvIDw9ICQoJ2xpLnNjcmVlbl9saXN0JykubGVuZ3RoIHx8IG8gPT0gTmFOICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrbysnXCJdJykuc2xpZGVEb3duKHBhcmFtcy5zcGVlZEltZyk7IH0sdGltZU91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6Zmlyc3QnKS5zbGlkZURvd24ocGFyYW1zLnNwZWVkSW1nKTsgfSx0aW1lT3V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAkKFwiI1wiK3VuaXFJZCkub2ZmKCdjbGljaycsICcuc2NyZWVuX25hdl9sZWZ0Jykub24oJ2NsaWNrJywgJy5zY3JlZW5fbmF2X2xlZnQnLCBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgdmFyIGcgPSAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6dmlzaWJsZScpLmF0dHIoJ2RhdGEtc2NyZWVuJylcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHBhcnNlSW50KGcpLTE7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVPdXQgPSBwYXJhbXMuc3BlZWRJbWcgKyAxMDA7XG5cbiAgICAgICAgICAgICAgICBpZiggcGFyYW1zLmVmZmVjdEltZyA9PT0gXCJzbGlkZVwiICl7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytnKydcIl0nKS5zbGlkZVVwKHBhcmFtcy5zcGVlZEltZylcblxuICAgICAgICAgICAgICAgICAgICBpZiggbyA+PSAxICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrbysnXCJdJykuc2xpZGVEb3duKHBhcmFtcy5zcGVlZEltZyk7IH0sdGltZU91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6bGFzdCcpLnNsaWRlRG93bihwYXJhbXMuc3BlZWRJbWcpOyB9LHRpbWVPdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIHBhcmFtcy5lZmZlY3RJbWcgPT09IFwiZmFkZVwiICl7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytnKydcIl0nKS5mYWRlT3V0KHBhcmFtcy5zcGVlZEltZylcblxuICAgICAgICAgICAgICAgICAgICBpZiggbyA+PSAxICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrbysnXCJdJykuZmFkZUluKHBhcmFtcy5zcGVlZEltZyk7IH0sdGltZU91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6bGFzdCcpLmZhZGVJbihwYXJhbXMuc3BlZWRJbWcpOyB9LHRpbWVPdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICAgICAgICBVSSBFZmZlY3RcbiAgICAgICAgICAgICAgICAqKioqKioqKioqKioqKioqL1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCBwYXJhbXMuZWZmZWN0SW1nID09PSBcImJvdW5jZVwiICl7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytnKydcIl0nKS5mYWRlT3V0KHBhcmFtcy5zcGVlZEltZylcblxuICAgICAgICAgICAgICAgICAgICBpZiggbyA+PSAxICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrbysnXCJdJykuZmFkZUluKHBhcmFtcy5zcGVlZEltZykuZWZmZWN0KCdib3VuY2UnKTsgfSx0aW1lT3V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaTpsYXN0JykuZmFkZUluKHBhcmFtcy5zcGVlZEltZykuZWZmZWN0KCdib3VuY2UnKTsgfSx0aW1lT3V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgndWwuc2NyZWVuX2Jsb2NrJykuY2hpbGRyZW4oJ2xpW2RhdGEtc2NyZWVuPVwiJytnKydcIl0nKS5zbGlkZVVwKHBhcmFtcy5zcGVlZEltZylcblxuICAgICAgICAgICAgICAgICAgICBpZiggbyA+PSAxICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ICQoJ3VsLnNjcmVlbl9ibG9jaycpLmNoaWxkcmVuKCdsaVtkYXRhLXNjcmVlbj1cIicrbysnXCJdJykuc2xpZGVEb3duKHBhcmFtcy5zcGVlZEltZyk7IH0sdGltZU91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyAkKCd1bC5zY3JlZW5fYmxvY2snKS5jaGlsZHJlbignbGk6bGFzdCcpLnNsaWRlRG93bihwYXJhbXMuc3BlZWRJbWcpOyB9LHRpbWVPdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICB9KTtcblxuXG5cbiAgICB9XG5cbn0pKCBqUXVlcnkgKTtcblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIElOQ0xVREUgalFVRVJZIFVJXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuKGZ1bmN0aW9uKCAkICkge1xuXG4gICAgJC51aSA9ICQudWkgfHwge307XG5cbiAgICB2YXIgdmVyc2lvbiA9ICQudWkudmVyc2lvbiA9IFwiMS4xMi4xXCI7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIDEuMTIuMVxuICAgICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAgICAgKlxuICAgICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICAgICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAgICAgKi9cblxuICAgIC8vPj5sYWJlbDogRWZmZWN0cyBDb3JlXG4gICAgLy8+Pmdyb3VwOiBFZmZlY3RzXG4gICAgLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4gICAgLy8+PmRlc2NyaXB0aW9uOiBFeHRlbmRzIHRoZSBpbnRlcm5hbCBqUXVlcnkgZWZmZWN0cy4gSW5jbHVkZXMgbW9ycGhpbmcgYW5kIGVhc2luZy4gUmVxdWlyZWQgYnkgYWxsIG90aGVyIGVmZmVjdHMuXG4gICAgLy8ganNjczplbmFibGUgbWF4aW11bUxpbmVMZW5ndGhcbiAgICAvLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2F0ZWdvcnkvZWZmZWN0cy1jb3JlL1xuICAgIC8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG4gICAgdmFyIGRhdGFTcGFjZSA9IFwidWktZWZmZWN0cy1cIixcbiAgICAgICAgZGF0YVNwYWNlU3R5bGUgPSBcInVpLWVmZmVjdHMtc3R5bGVcIixcbiAgICAgICAgZGF0YVNwYWNlQW5pbWF0ZWQgPSBcInVpLWVmZmVjdHMtYW5pbWF0ZWRcIixcblxuICAgICAgICAvLyBDcmVhdGUgYSBsb2NhbCBqUXVlcnkgYmVjYXVzZSBqUXVlcnkgQ29sb3IgcmVsaWVzIG9uIGl0IGFuZCB0aGVcbiAgICAgICAgLy8gZ2xvYmFsIG1heSBub3QgZXhpc3Qgd2l0aCBBTUQgYW5kIGEgY3VzdG9tIGJ1aWxkICgjMTAxOTkpXG4gICAgICAgIGpRdWVyeSA9ICQ7XG5cbiAgICAkLmVmZmVjdHMgPSB7XG4gICAgICAgIGVmZmVjdDoge31cbiAgICB9O1xuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IENvbG9yIEFuaW1hdGlvbnMgdjIuMS4yXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktY29sb3JcbiAgICAgKlxuICAgICAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqXG4gICAgICogRGF0ZTogV2VkIEphbiAxNiAwODo0NzowOSAyMDEzIC0wNjAwXG4gICAgICovXG4gICAgKCBmdW5jdGlvbiggalF1ZXJ5LCB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIHN0ZXBIb29rcyA9IFwiYmFja2dyb3VuZENvbG9yIGJvcmRlckJvdHRvbUNvbG9yIGJvcmRlckxlZnRDb2xvciBib3JkZXJSaWdodENvbG9yIFwiICtcbiAgICAgICAgICAgIFwiYm9yZGVyVG9wQ29sb3IgY29sb3IgY29sdW1uUnVsZUNvbG9yIG91dGxpbmVDb2xvciB0ZXh0RGVjb3JhdGlvbkNvbG9yIHRleHRFbXBoYXNpc0NvbG9yXCIsXG5cbiAgICAgICAgLy8gUGx1c2VxdWFscyB0ZXN0IGZvciArPSAxMDAgLT0gMTAwXG4gICAgICAgIHJwbHVzZXF1YWxzID0gL14oW1xcLStdKT1cXHMqKFxcZCtcXC4/XFxkKikvLFxuXG4gICAgICAgIC8vIEEgc2V0IG9mIFJFJ3MgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncyBhbmQgZ2VuZXJhdGUgY29sb3IgdHVwbGVzLlxuICAgICAgICBzdHJpbmdQYXJzZXJzID0gWyB7XG4gICAgICAgICAgICAgICAgcmU6IC9yZ2JhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqKD86LFxccyooXFxkPyg/OlxcLlxcZCspPylcXHMqKT9cXCkvLFxuICAgICAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDIgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDMgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDQgXVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL3JnYmE/XFwoXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG4gICAgICAgICAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKCBleGVjUmVzdWx0ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1Jlc3VsdFsgMSBdICogMi41NSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDIgXSAqIDIuNTUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjUmVzdWx0WyAzIF0gKiAyLjU1LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1Jlc3VsdFsgNCBdXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWdleCBpZ25vcmVzIEEtRiBiZWNhdXNlIGl0J3MgY29tcGFyZWQgYWdhaW5zdCBhbiBhbHJlYWR5IGxvd2VyY2FzZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgcmU6IC8jKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pLyxcbiAgICAgICAgICAgICAgICBwYXJzZTogZnVuY3Rpb24oIGV4ZWNSZXN1bHQgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludCggZXhlY1Jlc3VsdFsgMSBdLCAxNiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDIgXSwgMTYgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCBleGVjUmVzdWx0WyAzIF0sIDE2IClcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlZ2V4IGlnbm9yZXMgQS1GIGJlY2F1c2UgaXQncyBjb21wYXJlZCBhZ2FpbnN0IGFuIGFscmVhZHkgbG93ZXJjYXNlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICByZTogLyMoW2EtZjAtOV0pKFthLWYwLTldKShbYS1mMC05XSkvLFxuICAgICAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KCBleGVjUmVzdWx0WyAxIF0gKyBleGVjUmVzdWx0WyAxIF0sIDE2ICksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludCggZXhlY1Jlc3VsdFsgMiBdICsgZXhlY1Jlc3VsdFsgMiBdLCAxNiApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoIGV4ZWNSZXN1bHRbIDMgXSArIGV4ZWNSZXN1bHRbIDMgXSwgMTYgKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZTogL2hzbGE/XFwoXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxcJVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sXG4gICAgICAgICAgICAgICAgc3BhY2U6IFwiaHNsYVwiLFxuICAgICAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbiggZXhlY1Jlc3VsdCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDEgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDIgXSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDMgXSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbIDQgXVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXSxcblxuICAgICAgICAvLyBKUXVlcnkuQ29sb3IoIClcbiAgICAgICAgY29sb3IgPSBqUXVlcnkuQ29sb3IgPSBmdW5jdGlvbiggY29sb3IsIGdyZWVuLCBibHVlLCBhbHBoYSApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkNvbG9yLmZuLnBhcnNlKCBjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhICk7XG4gICAgICAgIH0sXG4gICAgICAgIHNwYWNlcyA9IHtcbiAgICAgICAgICAgIHJnYmE6IHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICByZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZVwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdyZWVuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaHNsYToge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGh1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkZWdyZWVzXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2F0dXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwZXJjZW50XCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGlnaHRuZXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBlcmNlbnRcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcm9wVHlwZXMgPSB7XG4gICAgICAgICAgICBcImJ5dGVcIjoge1xuICAgICAgICAgICAgICAgIGZsb29yOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1heDogMjU1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwZXJjZW50XCI6IHtcbiAgICAgICAgICAgICAgICBtYXg6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRlZ3JlZXNcIjoge1xuICAgICAgICAgICAgICAgIG1vZDogMzYwLFxuICAgICAgICAgICAgICAgIGZsb29yOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1cHBvcnQgPSBjb2xvci5zdXBwb3J0ID0ge30sXG5cbiAgICAgICAgLy8gRWxlbWVudCBmb3Igc3VwcG9ydCB0ZXN0c1xuICAgICAgICBzdXBwb3J0RWxlbSA9IGpRdWVyeSggXCI8cD5cIiApWyAwIF0sXG5cbiAgICAgICAgLy8gQ29sb3JzID0galF1ZXJ5LkNvbG9yLm5hbWVzXG4gICAgICAgIGNvbG9ycyxcblxuICAgICAgICAvLyBMb2NhbCBhbGlhc2VzIG9mIGZ1bmN0aW9ucyBjYWxsZWQgb2Z0ZW5cbiAgICAgICAgZWFjaCA9IGpRdWVyeS5lYWNoO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHJnYmEgc3VwcG9ydCBpbW1lZGlhdGVseVxuICAgIHN1cHBvcnRFbGVtLnN0eWxlLmNzc1RleHQgPSBcImJhY2tncm91bmQtY29sb3I6cmdiYSgxLDEsMSwuNSlcIjtcbiAgICBzdXBwb3J0LnJnYmEgPSBzdXBwb3J0RWxlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IuaW5kZXhPZiggXCJyZ2JhXCIgKSA+IC0xO1xuXG4gICAgLy8gRGVmaW5lIGNhY2hlIG5hbWUgYW5kIGFscGhhIHByb3BlcnRpZXNcbiAgICAvLyBmb3IgcmdiYSBhbmQgaHNsYSBzcGFjZXNcbiAgICBlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuICAgICAgICBzcGFjZS5jYWNoZSA9IFwiX1wiICsgc3BhY2VOYW1lO1xuICAgICAgICBzcGFjZS5wcm9wcy5hbHBoYSA9IHtcbiAgICAgICAgICAgIGlkeDogMyxcbiAgICAgICAgICAgIHR5cGU6IFwicGVyY2VudFwiLFxuICAgICAgICAgICAgZGVmOiAxXG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBwcm9wLCBhbGxvd0VtcHR5ICkge1xuICAgICAgICB2YXIgdHlwZSA9IHByb3BUeXBlc1sgcHJvcC50eXBlIF0gfHwge307XG5cbiAgICAgICAgaWYgKCB2YWx1ZSA9PSBudWxsICkge1xuICAgICAgICAgICAgcmV0dXJuICggYWxsb3dFbXB0eSB8fCAhcHJvcC5kZWYgKSA/IG51bGwgOiBwcm9wLmRlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIH5+IGlzIGFuIHNob3J0IHdheSBvZiBkb2luZyBmbG9vciBmb3IgcG9zaXRpdmUgbnVtYmVyc1xuICAgICAgICB2YWx1ZSA9IHR5cGUuZmxvb3IgPyB+fnZhbHVlIDogcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuICAgICAgICAvLyBJRSB3aWxsIHBhc3MgaW4gZW1wdHkgc3RyaW5ncyBhcyB2YWx1ZSBmb3IgYWxwaGEsXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgaGl0IHRoaXMgY2FzZVxuICAgICAgICBpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AuZGVmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0eXBlLm1vZCApIHtcblxuICAgICAgICAgICAgLy8gV2UgYWRkIG1vZCBiZWZvcmUgbW9kZGluZyB0byBtYWtlIHN1cmUgdGhhdCBuZWdhdGl2ZXMgdmFsdWVzXG4gICAgICAgICAgICAvLyBnZXQgY29udmVydGVkIHByb3Blcmx5OiAtMTAgLT4gMzUwXG4gICAgICAgICAgICByZXR1cm4gKCB2YWx1ZSArIHR5cGUubW9kICkgJSB0eXBlLm1vZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBub3cgYWxsIHByb3BlcnR5IHR5cGVzIHdpdGhvdXQgbW9kIGhhdmUgbWluIGFuZCBtYXhcbiAgICAgICAgcmV0dXJuIDAgPiB2YWx1ZSA/IDAgOiB0eXBlLm1heCA8IHZhbHVlID8gdHlwZS5tYXggOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdQYXJzZSggc3RyaW5nICkge1xuICAgICAgICB2YXIgaW5zdCA9IGNvbG9yKCksXG4gICAgICAgICAgICByZ2JhID0gaW5zdC5fcmdiYSA9IFtdO1xuXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGVhY2goIHN0cmluZ1BhcnNlcnMsIGZ1bmN0aW9uKCBpLCBwYXJzZXIgKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkLFxuICAgICAgICAgICAgICAgIG1hdGNoID0gcGFyc2VyLnJlLmV4ZWMoIHN0cmluZyApLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IG1hdGNoICYmIHBhcnNlci5wYXJzZSggbWF0Y2ggKSxcbiAgICAgICAgICAgICAgICBzcGFjZU5hbWUgPSBwYXJzZXIuc3BhY2UgfHwgXCJyZ2JhXCI7XG5cbiAgICAgICAgICAgIGlmICggdmFsdWVzICkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IGluc3RbIHNwYWNlTmFtZSBdKCB2YWx1ZXMgKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGFuIHJnYmEgcGFyc2UgdGhlIGFzc2lnbm1lbnQgbWlnaHQgaGFwcGVuIHR3aWNlXG4gICAgICAgICAgICAgICAgLy8gb2ggd2VsbC4uLi5cbiAgICAgICAgICAgICAgICBpbnN0WyBzcGFjZXNbIHNwYWNlTmFtZSBdLmNhY2hlIF0gPSBwYXJzZWRbIHNwYWNlc1sgc3BhY2VOYW1lIF0uY2FjaGUgXTtcbiAgICAgICAgICAgICAgICByZ2JhID0gaW5zdC5fcmdiYSA9IHBhcnNlZC5fcmdiYTtcblxuICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFjaCggc3RyaW5nUGFyc2VycyApIGhlcmUgYmVjYXVzZSB3ZSBtYXRjaGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgLy8gRm91bmQgYSBzdHJpbmdQYXJzZXIgdGhhdCBoYW5kbGVkIGl0XG4gICAgICAgIGlmICggcmdiYS5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgY2FtZSBmcm9tIGEgcGFyc2VkIHN0cmluZywgZm9yY2UgXCJ0cmFuc3BhcmVudFwiIHdoZW4gYWxwaGEgaXMgMFxuICAgICAgICAgICAgLy8gY2hyb21lLCAoYW5kIG1heWJlIG90aGVycykgcmV0dXJuIFwidHJhbnNwYXJlbnRcIiBhcyByZ2JhKDAsMCwwLDApXG4gICAgICAgICAgICBpZiAoIHJnYmEuam9pbigpID09PSBcIjAsMCwwLDBcIiApIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKCByZ2JhLCBjb2xvcnMudHJhbnNwYXJlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmFtZWQgY29sb3JzXG4gICAgICAgIHJldHVybiBjb2xvcnNbIHN0cmluZyBdO1xuICAgIH1cblxuICAgIGNvbG9yLmZuID0galF1ZXJ5LmV4dGVuZCggY29sb3IucHJvdG90eXBlLCB7XG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiggcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgKSB7XG4gICAgICAgICAgICBpZiAoIHJlZCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JnYmEgPSBbIG51bGwsIG51bGwsIG51bGwsIG51bGwgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggcmVkLmpxdWVyeSB8fCByZWQubm9kZVR5cGUgKSB7XG4gICAgICAgICAgICAgICAgcmVkID0galF1ZXJ5KCByZWQgKS5jc3MoIGdyZWVuICk7XG4gICAgICAgICAgICAgICAgZ3JlZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnN0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICB0eXBlID0galF1ZXJ5LnR5cGUoIHJlZCApLFxuICAgICAgICAgICAgICAgIHJnYmEgPSB0aGlzLl9yZ2JhID0gW107XG5cbiAgICAgICAgICAgIC8vIE1vcmUgdGhhbiAxIGFyZ3VtZW50IHNwZWNpZmllZCAtIGFzc3VtZSAoIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIClcbiAgICAgICAgICAgIGlmICggZ3JlZW4gIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICByZWQgPSBbIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIF07XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKCBzdHJpbmdQYXJzZSggcmVkICkgfHwgY29sb3JzLl9kZWZhdWx0ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJhcnJheVwiICkge1xuICAgICAgICAgICAgICAgIGVhY2goIHNwYWNlcy5yZ2JhLnByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuICAgICAgICAgICAgICAgICAgICByZ2JhWyBwcm9wLmlkeCBdID0gY2xhbXAoIHJlZFsgcHJvcC5pZHggXSwgcHJvcCApO1xuICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0eXBlID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAgICAgICAgIGlmICggcmVkIGluc3RhbmNlb2YgY29sb3IgKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHJlZFsgc3BhY2UuY2FjaGUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0WyBzcGFjZS5jYWNoZSBdID0gcmVkWyBzcGFjZS5jYWNoZSBdLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gc3BhY2UuY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKCBzcGFjZS5wcm9wcywgZnVuY3Rpb24oIGtleSwgcHJvcCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjYWNoZSBkb2Vzbid0IGV4aXN0LCBhbmQgd2Uga25vdyBob3cgdG8gY29udmVydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggIWluc3RbIGNhY2hlIF0gJiYgc3BhY2UudG8gKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIHdhcyBudWxsLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGtleSB3YXMgYWxwaGEsIHdlIGRvbid0IG5lZWQgdG8gY29weSBpdCBlaXRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBrZXkgPT09IFwiYWxwaGFcIiB8fCByZWRbIGtleSBdID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdFsgY2FjaGUgXSA9IHNwYWNlLnRvKCBpbnN0Ll9yZ2JhICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZXJlIHdlIGFsbG93IG51bGxzIGZvciBBTEwgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGNsYW1wIHdpdGggYWx3YXlzQWxsb3dFbXB0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RbIGNhY2hlIF1bIHByb3AuaWR4IF0gPSBjbGFtcCggcmVkWyBrZXkgXSwgcHJvcCwgdHJ1ZSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGRlZmluZWQgYnV0IGFscGhhP1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpbnN0WyBjYWNoZSBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KCBudWxsLCBpbnN0WyBjYWNoZSBdLnNsaWNlKCAwLCAzICkgKSA8IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHQgb2YgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RbIGNhY2hlIF1bIDMgXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBzcGFjZS5mcm9tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0Ll9yZ2JhID0gc3BhY2UuZnJvbSggaW5zdFsgY2FjaGUgXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXM6IGZ1bmN0aW9uKCBjb21wYXJlICkge1xuICAgICAgICAgICAgdmFyIGlzID0gY29sb3IoIGNvbXBhcmUgKSxcbiAgICAgICAgICAgICAgICBzYW1lID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0ID0gdGhpcztcblxuICAgICAgICAgICAgZWFjaCggc3BhY2VzLCBmdW5jdGlvbiggXywgc3BhY2UgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FjaGUgPSBpc1sgc3BhY2UuY2FjaGUgXTtcbiAgICAgICAgICAgICAgICBpZiAoIGlzQ2FjaGUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsQ2FjaGUgPSBpbnN0WyBzcGFjZS5jYWNoZSBdIHx8IHNwYWNlLnRvICYmIHNwYWNlLnRvKCBpbnN0Ll9yZ2JhICkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGVhY2goIHNwYWNlLnByb3BzLCBmdW5jdGlvbiggXywgcHJvcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaXNDYWNoZVsgcHJvcC5pZHggXSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgPSAoIGlzQ2FjaGVbIHByb3AuaWR4IF0gPT09IGxvY2FsQ2FjaGVbIHByb3AuaWR4IF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2FtZTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1lO1xuICAgICAgICB9LFxuICAgICAgICBfc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHVzZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBpbnN0ID0gdGhpcztcbiAgICAgICAgICAgIGVhY2goIHNwYWNlcywgZnVuY3Rpb24oIHNwYWNlTmFtZSwgc3BhY2UgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBpbnN0WyBzcGFjZS5jYWNoZSBdICkge1xuICAgICAgICAgICAgICAgICAgICB1c2VkLnB1c2goIHNwYWNlTmFtZSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VkLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiggb3RoZXIsIGRpc3RhbmNlICkge1xuICAgICAgICAgICAgdmFyIGVuZCA9IGNvbG9yKCBvdGhlciApLFxuICAgICAgICAgICAgICAgIHNwYWNlTmFtZSA9IGVuZC5fc3BhY2UoKSxcbiAgICAgICAgICAgICAgICBzcGFjZSA9IHNwYWNlc1sgc3BhY2VOYW1lIF0sXG4gICAgICAgICAgICAgICAgc3RhcnRDb2xvciA9IHRoaXMuYWxwaGEoKSA9PT0gMCA/IGNvbG9yKCBcInRyYW5zcGFyZW50XCIgKSA6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydENvbG9yWyBzcGFjZS5jYWNoZSBdIHx8IHNwYWNlLnRvKCBzdGFydENvbG9yLl9yZ2JhICksXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RhcnQuc2xpY2UoKTtcblxuICAgICAgICAgICAgZW5kID0gZW5kWyBzcGFjZS5jYWNoZSBdO1xuICAgICAgICAgICAgZWFjaCggc3BhY2UucHJvcHMsIGZ1bmN0aW9uKCBrZXksIHByb3AgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcHJvcC5pZHgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydFsgaW5kZXggXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kVmFsdWUgPSBlbmRbIGluZGV4IF0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBwcm9wVHlwZXNbIHByb3AudHlwZSBdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgbnVsbCwgZG9uJ3Qgb3ZlcnJpZGUgc3RhcnQgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoIGVuZFZhbHVlID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgbnVsbCAtIHVzZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoIHN0YXJ0VmFsdWUgPT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsgaW5kZXggXSA9IGVuZFZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggdHlwZS5tb2QgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSA+IHR5cGUubW9kIC8gMiApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFZhbHVlICs9IHR5cGUubW9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc3RhcnRWYWx1ZSAtIGVuZFZhbHVlID4gdHlwZS5tb2QgLyAyICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWUgLT0gdHlwZS5tb2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WyBpbmRleCBdID0gY2xhbXAoICggZW5kVmFsdWUgLSBzdGFydFZhbHVlICkgKiBkaXN0YW5jZSArIHN0YXJ0VmFsdWUsIHByb3AgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1sgc3BhY2VOYW1lIF0oIHJlc3VsdCApO1xuICAgICAgICB9LFxuICAgICAgICBibGVuZDogZnVuY3Rpb24oIG9wYXF1ZSApIHtcblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgb3BhcXVlIC0gcmV0dXJuIG91cnNlbGZcbiAgICAgICAgICAgIGlmICggdGhpcy5fcmdiYVsgMyBdID09PSAxICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmdiID0gdGhpcy5fcmdiYS5zbGljZSgpLFxuICAgICAgICAgICAgICAgIGEgPSByZ2IucG9wKCksXG4gICAgICAgICAgICAgICAgYmxlbmQgPSBjb2xvciggb3BhcXVlICkuX3JnYmE7XG5cbiAgICAgICAgICAgIHJldHVybiBjb2xvciggalF1ZXJ5Lm1hcCggcmdiLCBmdW5jdGlvbiggdiwgaSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCAxIC0gYSApICogYmxlbmRbIGkgXSArIGEgKiB2O1xuICAgICAgICAgICAgfSApICk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvUmdiYVN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gXCJyZ2JhKFwiLFxuICAgICAgICAgICAgICAgIHJnYmEgPSBqUXVlcnkubWFwKCB0aGlzLl9yZ2JhLCBmdW5jdGlvbiggdiwgaSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPT0gbnVsbCA/ICggaSA+IDIgPyAxIDogMCApIDogdjtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIGlmICggcmdiYVsgMyBdID09PSAxICkge1xuICAgICAgICAgICAgICAgIHJnYmEucG9wKCk7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJyZ2IoXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyByZ2JhLmpvaW4oKSArIFwiKVwiO1xuICAgICAgICB9LFxuICAgICAgICB0b0hzbGFTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IFwiaHNsYShcIixcbiAgICAgICAgICAgICAgICBoc2xhID0galF1ZXJ5Lm1hcCggdGhpcy5oc2xhKCksIGZ1bmN0aW9uKCB2LCBpICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHYgPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBpID4gMiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2F0Y2ggMSBhbmQgMlxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgJiYgaSA8IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gTWF0aC5yb3VuZCggdiAqIDEwMCApICsgXCIlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICBpZiAoIGhzbGFbIDMgXSA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBoc2xhLnBvcCgpO1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiaHNsKFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGhzbGEuam9pbigpICsgXCIpXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbiggaW5jbHVkZUFscGhhICkge1xuICAgICAgICAgICAgdmFyIHJnYmEgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgYWxwaGEgPSByZ2JhLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoIGluY2x1ZGVBbHBoYSApIHtcbiAgICAgICAgICAgICAgICByZ2JhLnB1c2goIH5+KCBhbHBoYSAqIDI1NSApICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcIiNcIiArIGpRdWVyeS5tYXAoIHJnYmEsIGZ1bmN0aW9uKCB2ICkge1xuXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byAwIHdoZW4gbnVsbHMgZXhpc3RcbiAgICAgICAgICAgICAgICB2ID0gKCB2IHx8IDAgKS50b1N0cmluZyggMTYgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPT09IDEgPyBcIjBcIiArIHYgOiB2O1xuICAgICAgICAgICAgfSApLmpvaW4oIFwiXCIgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JnYmFbIDMgXSA9PT0gMCA/IFwidHJhbnNwYXJlbnRcIiA6IHRoaXMudG9SZ2JhU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9ICk7XG4gICAgY29sb3IuZm4ucGFyc2UucHJvdG90eXBlID0gY29sb3IuZm47XG5cbiAgICAvLyBIc2xhIGNvbnZlcnNpb25zIGFkYXB0ZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL21hYXNoYWFjay9zb3VyY2UvYnJvd3NlL3BhY2thZ2VzL2dyYXBoaWNzL3RydW5rL3NyYy9ncmFwaGljcy9jb2xvcnMvSFVFMlJHQi5hcz9yPTUwMjFcblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIGggKSB7XG4gICAgICAgIGggPSAoIGggKyAxICkgJSAxO1xuICAgICAgICBpZiAoIGggKiA2IDwgMSApIHtcbiAgICAgICAgICAgIHJldHVybiBwICsgKCBxIC0gcCApICogaCAqIDY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBoICogMiA8IDEgKSB7XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGggKiAzIDwgMiApIHtcbiAgICAgICAgICAgIHJldHVybiBwICsgKCBxIC0gcCApICogKCAoIDIgLyAzICkgLSBoICkgKiA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHNwYWNlcy5oc2xhLnRvID0gZnVuY3Rpb24oIHJnYmEgKSB7XG4gICAgICAgIGlmICggcmdiYVsgMCBdID09IG51bGwgfHwgcmdiYVsgMSBdID09IG51bGwgfHwgcmdiYVsgMiBdID09IG51bGwgKSB7XG4gICAgICAgICAgICByZXR1cm4gWyBudWxsLCBudWxsLCBudWxsLCByZ2JhWyAzIF0gXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHJnYmFbIDAgXSAvIDI1NSxcbiAgICAgICAgICAgIGcgPSByZ2JhWyAxIF0gLyAyNTUsXG4gICAgICAgICAgICBiID0gcmdiYVsgMiBdIC8gMjU1LFxuICAgICAgICAgICAgYSA9IHJnYmFbIDMgXSxcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICksXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApLFxuICAgICAgICAgICAgZGlmZiA9IG1heCAtIG1pbixcbiAgICAgICAgICAgIGFkZCA9IG1heCArIG1pbixcbiAgICAgICAgICAgIGwgPSBhZGQgKiAwLjUsXG4gICAgICAgICAgICBoLCBzO1xuXG4gICAgICAgIGlmICggbWluID09PSBtYXggKSB7XG4gICAgICAgICAgICBoID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICggciA9PT0gbWF4ICkge1xuICAgICAgICAgICAgaCA9ICggNjAgKiAoIGcgLSBiICkgLyBkaWZmICkgKyAzNjA7XG4gICAgICAgIH0gZWxzZSBpZiAoIGcgPT09IG1heCApIHtcbiAgICAgICAgICAgIGggPSAoIDYwICogKCBiIC0gciApIC8gZGlmZiApICsgMTIwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCA9ICggNjAgKiAoIHIgLSBnICkgLyBkaWZmICkgKyAyNDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaHJvbWEgKGRpZmYpID09IDAgbWVhbnMgZ3JleXNjYWxlIHdoaWNoLCBieSBkZWZpbml0aW9uLCBzYXR1cmF0aW9uID0gMCVcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBzYXR1cmF0aW9uIGlzIGJhc2VkIG9uIHRoZSByYXRpbyBvZiBjaHJvbWEgKGRpZmYpIHRvIGxpZ2h0bmVzcyAoYWRkKVxuICAgICAgICBpZiAoIGRpZmYgPT09IDAgKSB7XG4gICAgICAgICAgICBzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICggbCA8PSAwLjUgKSB7XG4gICAgICAgICAgICBzID0gZGlmZiAvIGFkZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBkaWZmIC8gKCAyIC0gYWRkICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsgTWF0aC5yb3VuZCggaCApICUgMzYwLCBzLCBsLCBhID09IG51bGwgPyAxIDogYSBdO1xuICAgIH07XG5cbiAgICBzcGFjZXMuaHNsYS5mcm9tID0gZnVuY3Rpb24oIGhzbGEgKSB7XG4gICAgICAgIGlmICggaHNsYVsgMCBdID09IG51bGwgfHwgaHNsYVsgMSBdID09IG51bGwgfHwgaHNsYVsgMiBdID09IG51bGwgKSB7XG4gICAgICAgICAgICByZXR1cm4gWyBudWxsLCBudWxsLCBudWxsLCBoc2xhWyAzIF0gXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9IGhzbGFbIDAgXSAvIDM2MCxcbiAgICAgICAgICAgIHMgPSBoc2xhWyAxIF0sXG4gICAgICAgICAgICBsID0gaHNsYVsgMiBdLFxuICAgICAgICAgICAgYSA9IGhzbGFbIDMgXSxcbiAgICAgICAgICAgIHEgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtIGwgKiBzLFxuICAgICAgICAgICAgcCA9IDIgKiBsIC0gcTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgTWF0aC5yb3VuZCggaHVlMnJnYiggcCwgcSwgaCArICggMSAvIDMgKSApICogMjU1ICksXG4gICAgICAgICAgICBNYXRoLnJvdW5kKCBodWUycmdiKCBwLCBxLCBoICkgKiAyNTUgKSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoIGh1ZTJyZ2IoIHAsIHEsIGggLSAoIDEgLyAzICkgKSAqIDI1NSApLFxuICAgICAgICAgICAgYVxuICAgICAgICBdO1xuICAgIH07XG5cbiAgICBlYWNoKCBzcGFjZXMsIGZ1bmN0aW9uKCBzcGFjZU5hbWUsIHNwYWNlICkge1xuICAgICAgICB2YXIgcHJvcHMgPSBzcGFjZS5wcm9wcyxcbiAgICAgICAgICAgIGNhY2hlID0gc3BhY2UuY2FjaGUsXG4gICAgICAgICAgICB0byA9IHNwYWNlLnRvLFxuICAgICAgICAgICAgZnJvbSA9IHNwYWNlLmZyb207XG5cbiAgICAgICAgLy8gTWFrZXMgcmdiYSgpIGFuZCBoc2xhKClcbiAgICAgICAgY29sb3IuZm5bIHNwYWNlTmFtZSBdID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGNhY2hlIGZvciB0aGlzIHNwYWNlIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmICggdG8gJiYgIXRoaXNbIGNhY2hlIF0gKSB7XG4gICAgICAgICAgICAgICAgdGhpc1sgY2FjaGUgXSA9IHRvKCB0aGlzLl9yZ2JhICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbIGNhY2hlIF0uc2xpY2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCxcbiAgICAgICAgICAgICAgICB0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICksXG4gICAgICAgICAgICAgICAgYXJyID0gKCB0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJvYmplY3RcIiApID8gdmFsdWUgOiBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzWyBjYWNoZSBdLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGVhY2goIHByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBhcnJbIHR5cGUgPT09IFwib2JqZWN0XCIgPyBrZXkgOiBwcm9wLmlkeCBdO1xuICAgICAgICAgICAgICAgIGlmICggdmFsID09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGxvY2FsWyBwcm9wLmlkeCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFsgcHJvcC5pZHggXSA9IGNsYW1wKCB2YWwsIHByb3AgKTtcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgaWYgKCBmcm9tICkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbG9yKCBmcm9tKCBsb2NhbCApICk7XG4gICAgICAgICAgICAgICAgcmV0WyBjYWNoZSBdID0gbG9jYWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKCBsb2NhbCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1ha2VzIHJlZCgpIGdyZWVuKCkgYmx1ZSgpIGFscGhhKCkgaHVlKCkgc2F0dXJhdGlvbigpIGxpZ2h0bmVzcygpXG4gICAgICAgIGVhY2goIHByb3BzLCBmdW5jdGlvbigga2V5LCBwcm9wICkge1xuXG4gICAgICAgICAgICAvLyBBbHBoYSBpcyBpbmNsdWRlZCBpbiBtb3JlIHRoYW4gb25lIHNwYWNlXG4gICAgICAgICAgICBpZiAoIGNvbG9yLmZuWyBrZXkgXSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xvci5mblsga2V5IF0gPSBmdW5jdGlvbiggdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZ0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICksXG4gICAgICAgICAgICAgICAgICAgIGZuID0gKCBrZXkgPT09IFwiYWxwaGFcIiA/ICggdGhpcy5faHNsYSA/IFwiaHNsYVwiIDogXCJyZ2JhXCIgKSA6IHNwYWNlTmFtZSApLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXNbIGZuIF0oKSxcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbG9jYWxbIHByb3AuaWR4IF0sXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB2dHlwZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIHZ0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCggdGhpcywgY3VyICk7XG4gICAgICAgICAgICAgICAgICAgIHZ0eXBlID0galF1ZXJ5LnR5cGUoIHZhbHVlICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICggdmFsdWUgPT0gbnVsbCAmJiBwcm9wLmVtcHR5ICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCB2dHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBycGx1c2VxdWFscy5leGVjKCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIG1hdGNoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjdXIgKyBwYXJzZUZsb2F0KCBtYXRjaFsgMiBdICkgKiAoIG1hdGNoWyAxIF0gPT09IFwiK1wiID8gMSA6IC0xICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxbIHByb3AuaWR4IF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1sgZm4gXSggbG9jYWwgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKTtcbiAgICB9ICk7XG5cbiAgICAvLyBBZGQgY3NzSG9vayBhbmQgLmZ4LnN0ZXAgZnVuY3Rpb24gZm9yIGVhY2ggbmFtZWQgaG9vay5cbiAgICAvLyBhY2NlcHQgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIHByb3BlcnRpZXNcbiAgICBjb2xvci5ob29rID0gZnVuY3Rpb24oIGhvb2sgKSB7XG4gICAgICAgIHZhciBob29rcyA9IGhvb2suc3BsaXQoIFwiIFwiICk7XG4gICAgICAgIGVhY2goIGhvb2tzLCBmdW5jdGlvbiggaSwgaG9vayApIHtcbiAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgaG9vayBdID0ge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkLCBjdXJFbGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlICE9PSBcInRyYW5zcGFyZW50XCIgJiYgKCBqUXVlcnkudHlwZSggdmFsdWUgKSAhPT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICggcGFyc2VkID0gc3RyaW5nUGFyc2UoIHZhbHVlICkgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xvciggcGFyc2VkIHx8IHZhbHVlICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFzdXBwb3J0LnJnYmEgJiYgdmFsdWUuX3JnYmFbIDMgXSAhPT0gMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJFbGVtID0gaG9vayA9PT0gXCJiYWNrZ3JvdW5kQ29sb3JcIiA/IGVsZW0ucGFyZW50Tm9kZSA6IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGJhY2tncm91bmRDb2xvciA9PT0gXCJcIiB8fCBiYWNrZ3JvdW5kQ29sb3IgPT09IFwidHJhbnNwYXJlbnRcIiApICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckVsZW0gJiYgY3VyRWxlbS5zdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0galF1ZXJ5LmNzcyggY3VyRWxlbSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRWxlbSA9IGN1ckVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoIGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmJsZW5kKCBiYWNrZ3JvdW5kQ29sb3IgJiYgYmFja2dyb3VuZENvbG9yICE9PSBcInRyYW5zcGFyZW50XCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIl9kZWZhdWx0XCIgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1JnYmFTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZVsgaG9vayBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKCBlICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwcGVkIHRvIHByZXZlbnQgSUUgZnJvbSB0aHJvd2luZyBlcnJvcnMgb24gXCJpbnZhbGlkXCIgdmFsdWVzIGxpa2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdhdXRvJyBvciAnaW5oZXJpdCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBqUXVlcnkuZnguc3RlcFsgaG9vayBdID0gZnVuY3Rpb24oIGZ4ICkge1xuICAgICAgICAgICAgICAgIGlmICggIWZ4LmNvbG9ySW5pdCApIHtcbiAgICAgICAgICAgICAgICAgICAgZnguc3RhcnQgPSBjb2xvciggZnguZWxlbSwgaG9vayApO1xuICAgICAgICAgICAgICAgICAgICBmeC5lbmQgPSBjb2xvciggZnguZW5kICk7XG4gICAgICAgICAgICAgICAgICAgIGZ4LmNvbG9ySW5pdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpRdWVyeS5jc3NIb29rc1sgaG9vayBdLnNldCggZnguZWxlbSwgZnguc3RhcnQudHJhbnNpdGlvbiggZnguZW5kLCBmeC5wb3MgKSApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApO1xuXG4gICAgfTtcblxuICAgIGNvbG9yLmhvb2soIHN0ZXBIb29rcyApO1xuXG4gICAgalF1ZXJ5LmNzc0hvb2tzLmJvcmRlckNvbG9yID0ge1xuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IHt9O1xuXG4gICAgICAgICAgICBlYWNoKCBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHBhcnQgKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kZWRbIFwiYm9yZGVyXCIgKyBwYXJ0ICsgXCJDb2xvclwiIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCYXNpYyBjb2xvciBuYW1lcyBvbmx5LlxuICAgIC8vIFVzYWdlIG9mIGFueSBvZiB0aGUgb3RoZXIgY29sb3IgbmFtZXMgcmVxdWlyZXMgYWRkaW5nIHlvdXJzZWxmIG9yIGluY2x1ZGluZ1xuICAgIC8vIGpxdWVyeS5jb2xvci5zdmctbmFtZXMuanMuXG4gICAgY29sb3JzID0galF1ZXJ5LkNvbG9yLm5hbWVzID0ge1xuXG4gICAgICAgIC8vIDQuMS4gQmFzaWMgY29sb3Iga2V5d29yZHNcbiAgICAgICAgYXF1YTogXCIjMDBmZmZmXCIsXG4gICAgICAgIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgICAgICAgYmx1ZTogXCIjMDAwMGZmXCIsXG4gICAgICAgIGZ1Y2hzaWE6IFwiI2ZmMDBmZlwiLFxuICAgICAgICBncmF5OiBcIiM4MDgwODBcIixcbiAgICAgICAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICAgICAgICBsaW1lOiBcIiMwMGZmMDBcIixcbiAgICAgICAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgICAgICAgbmF2eTogXCIjMDAwMDgwXCIsXG4gICAgICAgIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgICAgICAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgICAgICAgcmVkOiBcIiNmZjAwMDBcIixcbiAgICAgICAgc2lsdmVyOiBcIiNjMGMwYzBcIixcbiAgICAgICAgdGVhbDogXCIjMDA4MDgwXCIsXG4gICAgICAgIHdoaXRlOiBcIiNmZmZmZmZcIixcbiAgICAgICAgeWVsbG93OiBcIiNmZmZmMDBcIixcblxuICAgICAgICAvLyA0LjIuMy4gXCJ0cmFuc3BhcmVudFwiIGNvbG9yIGtleXdvcmRcbiAgICAgICAgdHJhbnNwYXJlbnQ6IFsgbnVsbCwgbnVsbCwgbnVsbCwgMCBdLFxuXG4gICAgICAgIF9kZWZhdWx0OiBcIiNmZmZmZmZcIlxuICAgIH07XG5cbiAgICB9ICkoIGpRdWVyeSApO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIENMQVNTIEFOSU1BVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgKCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBjbGFzc0FuaW1hdGlvbkFjdGlvbnMgPSBbIFwiYWRkXCIsIFwicmVtb3ZlXCIsIFwidG9nZ2xlXCIgXSxcbiAgICAgICAgc2hvcnRoYW5kU3R5bGVzID0ge1xuICAgICAgICAgICAgYm9yZGVyOiAxLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAxLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IDEsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiAxLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IDEsXG4gICAgICAgICAgICBib3JkZXJUb3A6IDEsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgICAgIG1hcmdpbjogMSxcbiAgICAgICAgICAgIHBhZGRpbmc6IDFcbiAgICAgICAgfTtcblxuICAgICQuZWFjaChcbiAgICAgICAgWyBcImJvcmRlckxlZnRTdHlsZVwiLCBcImJvcmRlclJpZ2h0U3R5bGVcIiwgXCJib3JkZXJCb3R0b21TdHlsZVwiLCBcImJvcmRlclRvcFN0eWxlXCIgXSxcbiAgICAgICAgZnVuY3Rpb24oIF8sIHByb3AgKSB7XG4gICAgICAgICAgICAkLmZ4LnN0ZXBbIHByb3AgXSA9IGZ1bmN0aW9uKCBmeCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIGZ4LmVuZCAhPT0gXCJub25lXCIgJiYgIWZ4LnNldEF0dHIgfHwgZngucG9zID09PSAxICYmICFmeC5zZXRBdHRyICkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUoIGZ4LmVsZW0sIHByb3AsIGZ4LmVuZCApO1xuICAgICAgICAgICAgICAgICAgICBmeC5zZXRBdHRyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTdHlsZXMoIGVsZW0gKSB7XG4gICAgICAgIHZhciBrZXksIGxlbixcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3ID9cbiAgICAgICAgICAgICAgICBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSwgbnVsbCApIDpcbiAgICAgICAgICAgICAgICBlbGVtLmN1cnJlbnRTdHlsZSxcbiAgICAgICAgICAgIHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoICYmIHN0eWxlWyAwIF0gJiYgc3R5bGVbIHN0eWxlWyAwIF0gXSApIHtcbiAgICAgICAgICAgIGxlbiA9IHN0eWxlLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICggbGVuLS0gKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3R5bGVbIGxlbiBdO1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHN0eWxlWyBrZXkgXSA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzWyAkLmNhbWVsQ2FzZSgga2V5ICkgXSA9IHN0eWxlWyBrZXkgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VwcG9ydDogT3BlcmEsIElFIDw5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKCBrZXkgaW4gc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlb2Ygc3R5bGVbIGtleSBdID09PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNbIGtleSBdID0gc3R5bGVbIGtleSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3R5bGVEaWZmZXJlbmNlKCBvbGRTdHlsZSwgbmV3U3R5bGUgKSB7XG4gICAgICAgIHZhciBkaWZmID0ge30sXG4gICAgICAgICAgICBuYW1lLCB2YWx1ZTtcblxuICAgICAgICBmb3IgKCBuYW1lIGluIG5ld1N0eWxlICkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXdTdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgaWYgKCBvbGRTdHlsZVsgbmFtZSBdICE9PSB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICBpZiAoICFzaG9ydGhhbmRTdHlsZXNbIG5hbWUgXSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmZ4LnN0ZXBbIG5hbWUgXSB8fCAhaXNOYU4oIHBhcnNlRmxvYXQoIHZhbHVlICkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZbIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydDogalF1ZXJ5IDwxLjhcbiAgICBpZiAoICEkLmZuLmFkZEJhY2sgKSB7XG4gICAgICAgICQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzID0gZnVuY3Rpb24oIHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgdmFyIG8gPSAkLnNwZWVkKCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRlZCA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICBiYXNlQ2xhc3MgPSBhbmltYXRlZC5hdHRyKCBcImNsYXNzXCIgKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFwcGx5Q2xhc3NDaGFuZ2UsXG4gICAgICAgICAgICAgICAgYWxsQW5pbWF0aW9ucyA9IG8uY2hpbGRyZW4gPyBhbmltYXRlZC5maW5kKCBcIipcIiApLmFkZEJhY2soKSA6IGFuaW1hdGVkO1xuXG4gICAgICAgICAgICAvLyBNYXAgdGhlIGFuaW1hdGVkIG9iamVjdHMgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIHN0eWxlcy5cbiAgICAgICAgICAgIGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJCggdGhpcyApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGdldEVsZW1lbnRTdHlsZXMoIHRoaXMgKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGNsYXNzIGNoYW5nZVxuICAgICAgICAgICAgYXBwbHlDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQuZWFjaCggY2xhc3NBbmltYXRpb25BY3Rpb25zLCBmdW5jdGlvbiggaSwgYWN0aW9uICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHZhbHVlWyBhY3Rpb24gXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkWyBhY3Rpb24gKyBcIkNsYXNzXCIgXSggdmFsdWVbIGFjdGlvbiBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXBwbHlDbGFzc0NoYW5nZSgpO1xuXG4gICAgICAgICAgICAvLyBNYXAgYWxsIGFuaW1hdGVkIG9iamVjdHMgYWdhaW4gLSBjYWxjdWxhdGUgbmV3IHN0eWxlcyBhbmQgZGlmZlxuICAgICAgICAgICAgYWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZCA9IGdldEVsZW1lbnRTdHlsZXMoIHRoaXMuZWxbIDAgXSApO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlmZiA9IHN0eWxlRGlmZmVyZW5jZSggdGhpcy5zdGFydCwgdGhpcy5lbmQgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgb3JpZ2luYWwgY2xhc3NcbiAgICAgICAgICAgIGFuaW1hdGVkLmF0dHIoIFwiY2xhc3NcIiwgYmFzZUNsYXNzICk7XG5cbiAgICAgICAgICAgIC8vIE1hcCBhbGwgYW5pbWF0ZWQgb2JqZWN0cyBhZ2FpbiAtIHRoaXMgdGltZSBjb2xsZWN0aW5nIGEgcHJvbWlzZVxuICAgICAgICAgICAgYWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVJbmZvID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZGZkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gJC5leHRlbmQoIHt9LCBvLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGZkLnJlc29sdmUoIHN0eWxlSW5mbyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVsLmFuaW1hdGUoIHRoaXMuZGlmZiwgb3B0cyApO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZmQucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSApO1xuXG4gICAgICAgICAgICAvLyBPbmNlIGFsbCBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkOlxuICAgICAgICAgICAgJC53aGVuLmFwcGx5KCAkLCBhbGxBbmltYXRpb25zLmdldCgpICkuZG9uZSggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGZpbmFsIGNsYXNzXG4gICAgICAgICAgICAgICAgYXBwbHlDbGFzc0NoYW5nZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggYW5pbWF0ZWQgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBhbGwgY3NzIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGFuaW1hdGVkXG4gICAgICAgICAgICAgICAgJC5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goIHRoaXMuZGlmZiwgZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmNzcygga2V5LCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGd1YXJudGVlZCB0byBiZSB0aGVyZSBpZiB5b3UgdXNlIGpRdWVyeS5zcGVlZCgpXG4gICAgICAgICAgICAgICAgLy8gaXQgYWxzbyBoYW5kbGVzIGRlcXVldWluZyB0aGUgbmV4dCBhbmltLi4uXG4gICAgICAgICAgICAgICAgby5jb21wbGV0ZS5jYWxsKCBhbmltYXRlZFsgMCBdICk7XG4gICAgICAgICAgICB9ICk7XG4gICAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgJC5mbi5leHRlbmQoIHtcbiAgICAgICAgYWRkQ2xhc3M6ICggZnVuY3Rpb24oIG9yaWcgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGNsYXNzTmFtZXMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVlZCA/XG4gICAgICAgICAgICAgICAgICAgICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgYWRkOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkgOlxuICAgICAgICAgICAgICAgICAgICBvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKSggJC5mbi5hZGRDbGFzcyApLFxuXG4gICAgICAgIHJlbW92ZUNsYXNzOiAoIGZ1bmN0aW9uKCBvcmlnICkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBjbGFzc05hbWVzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHJlbW92ZTogY2xhc3NOYW1lcyB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIDpcbiAgICAgICAgICAgICAgICAgICAgb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9ICkoICQuZm4ucmVtb3ZlQ2xhc3MgKSxcblxuICAgICAgICB0b2dnbGVDbGFzczogKCBmdW5jdGlvbiggb3JpZyApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggY2xhc3NOYW1lcywgZm9yY2UsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIGZvcmNlID09PSBcImJvb2xlYW5cIiB8fCBmb3JjZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFzcGVlZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCBzcGVlZCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwoIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBmb3JjZSA/IHsgYWRkOiBjbGFzc05hbWVzIH0gOiB7IHJlbW92ZTogY2xhc3NOYW1lcyB9ICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2l0aG91dCBmb3JjZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCggdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdG9nZ2xlOiBjbGFzc05hbWVzIH0sIGZvcmNlLCBzcGVlZCwgZWFzaW5nICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApKCAkLmZuLnRvZ2dsZUNsYXNzICksXG5cbiAgICAgICAgc3dpdGNoQ2xhc3M6IGZ1bmN0aW9uKCByZW1vdmUsIGFkZCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgYWRkOiBhZGQsXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmVcbiAgICAgICAgICAgIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cbiAgICB9ICkoKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVGRkVDVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgKCBmdW5jdGlvbigpIHtcblxuICAgIGlmICggJC5leHByICYmICQuZXhwci5maWx0ZXJzICYmICQuZXhwci5maWx0ZXJzLmFuaW1hdGVkICkge1xuICAgICAgICAkLmV4cHIuZmlsdGVycy5hbmltYXRlZCA9ICggZnVuY3Rpb24oIG9yaWcgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhJCggZWxlbSApLmRhdGEoIGRhdGFTcGFjZUFuaW1hdGVkICkgfHwgb3JpZyggZWxlbSApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApKCAkLmV4cHIuZmlsdGVycy5hbmltYXRlZCApO1xuICAgIH1cblxuICAgIGlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICkge1xuICAgICAgICAkLmV4dGVuZCggJC5lZmZlY3RzLCB7XG5cbiAgICAgICAgICAgIC8vIFNhdmVzIGEgc2V0IG9mIHByb3BlcnRpZXMgaW4gYSBkYXRhIHN0b3JhZ2VcbiAgICAgICAgICAgIHNhdmU6IGZ1bmN0aW9uKCBlbGVtZW50LCBzZXQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHNldFsgaSBdICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBzZXRbIGkgXSwgZWxlbWVudFsgMCBdLnN0eWxlWyBzZXRbIGkgXSBdICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBSZXN0b3JlcyBhIHNldCBvZiBwcmV2aW91c2x5IHNhdmVkIHByb3BlcnRpZXMgZnJvbSBhIGRhdGEgc3RvcmFnZVxuICAgICAgICAgICAgcmVzdG9yZTogZnVuY3Rpb24oIGVsZW1lbnQsIHNldCApIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsLCBpID0gMCwgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZXRbIGkgXSAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGVsZW1lbnQuZGF0YSggZGF0YVNwYWNlICsgc2V0WyBpIF0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCBzZXRbIGkgXSwgdmFsICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRNb2RlOiBmdW5jdGlvbiggZWwsIG1vZGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBtb2RlID09PSBcInRvZ2dsZVwiICkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gZWwuaXMoIFwiOmhpZGRlblwiICkgPyBcInNob3dcIiA6IFwiaGlkZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIFdyYXBzIHRoZSBlbGVtZW50IGFyb3VuZCBhIHdyYXBwZXIgdGhhdCBjb3BpZXMgcG9zaXRpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgY3JlYXRlV3JhcHBlcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHdyYXBwZWQsIHJldHVybiBpdFxuICAgICAgICAgICAgICAgIGlmICggZWxlbWVudC5wYXJlbnQoKS5pcyggXCIudWktZWZmZWN0cy13cmFwcGVyXCIgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50Lm91dGVyV2lkdGgoIHRydWUgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5vdXRlckhlaWdodCggdHJ1ZSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdFwiOiBlbGVtZW50LmNzcyggXCJmbG9hdFwiIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlciA9ICQoIFwiPGRpdj48L2Rpdj5cIiApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoIFwidWktZWZmZWN0cy13cmFwcGVyXCIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSApLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzaXplIGluIGNhc2Ugd2lkdGgvaGVpZ2h0IGFyZSBkZWZpbmVkIGluICUgLSBGaXhlcyAjNTI0NVxuICAgICAgICAgICAgICAgICAgICBzaXplID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQud2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHQoKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveFxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggaW5jb3JyZWN0bHkgZXhwb3NlcyBhbm9ueW1vdXMgY29udGVudFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU2MTY2NFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5pZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICggZSApIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LndyYXAoIHdyYXBwZXIgKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpeGVzICM3NTk1IC0gRWxlbWVudHMgbG9zZSBmb2N1cyB3aGVuIHdyYXBwZWQuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAkKCBhY3RpdmUgKS50cmlnZ2VyKCBcImZvY3VzXCIgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBIb3RmaXggZm9yIGpRdWVyeSAxLjQgc2luY2Ugc29tZSBjaGFuZ2UgaW4gd3JhcCgpIHNlZW1zIHRvIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgLy8gbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gZWxlbWVudC5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIHBvc2l0aW9uaW5nIHByb3BlcnRpZXMgdG8gdGhlIHdyYXBwZXJcbiAgICAgICAgICAgICAgICBpZiAoIGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5jc3MoIHsgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9ICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCB7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKCBwcm9wcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGVsZW1lbnQuY3NzKCBcInBvc2l0aW9uXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogZWxlbWVudC5jc3MoIFwiei1pbmRleFwiIClcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAkLmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIsIFwiYm90dG9tXCIsIFwicmlnaHRcIiBdLCBmdW5jdGlvbiggaSwgcG9zICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbIHBvcyBdID0gZWxlbWVudC5jc3MoIHBvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpc05hTiggcGFyc2VJbnQoIHByb3BzWyBwb3MgXSwgMTAgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyBwb3MgXSA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY3NzKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogXCJhdXRvXCJcbiAgICAgICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50LmNzcyggc2l6ZSApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuY3NzKCBwcm9wcyApLnNob3coKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbW92ZVdyYXBwZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtZW50LnBhcmVudCgpLmlzKCBcIi51aS1lZmZlY3RzLXdyYXBwZXJcIiApICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudCgpLnJlcGxhY2VXaXRoKCBlbGVtZW50ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZXMgIzc1OTUgLSBFbGVtZW50cyBsb3NlIGZvY3VzIHdoZW4gd3JhcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtZW50WyAwIF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKCBlbGVtZW50WyAwIF0sIGFjdGl2ZSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCggYWN0aXZlICkudHJpZ2dlciggXCJmb2N1c1wiICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuICAgIH1cblxuICAgICQuZXh0ZW5kKCAkLmVmZmVjdHMsIHtcbiAgICAgICAgdmVyc2lvbjogXCIxLjEyLjFcIixcblxuICAgICAgICBkZWZpbmU6IGZ1bmN0aW9uKCBuYW1lLCBtb2RlLCBlZmZlY3QgKSB7XG4gICAgICAgICAgICBpZiAoICFlZmZlY3QgKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gbW9kZTtcbiAgICAgICAgICAgICAgICBtb2RlID0gXCJlZmZlY3RcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJC5lZmZlY3RzLmVmZmVjdFsgbmFtZSBdID0gZWZmZWN0O1xuICAgICAgICAgICAgJC5lZmZlY3RzLmVmZmVjdFsgbmFtZSBdLm1vZGUgPSBtb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNjYWxlZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCBlbGVtZW50LCBwZXJjZW50LCBkaXJlY3Rpb24gKSB7XG4gICAgICAgICAgICBpZiAoIHBlcmNlbnQgPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJIZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIG91dGVyV2lkdGg6IDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgeCA9IGRpcmVjdGlvbiAhPT0gXCJob3Jpem9udGFsXCIgPyAoICggcGVyY2VudCB8fCAxMDAgKSAvIDEwMCApIDogMSxcbiAgICAgICAgICAgICAgICB5ID0gZGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIgPyAoICggcGVyY2VudCB8fCAxMDAgKSAvIDEwMCApIDogMTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0KCkgKiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoKCkgKiB4LFxuICAgICAgICAgICAgICAgIG91dGVySGVpZ2h0OiBlbGVtZW50Lm91dGVySGVpZ2h0KCkgKiB5LFxuICAgICAgICAgICAgICAgIG91dGVyV2lkdGg6IGVsZW1lbnQub3V0ZXJXaWR0aCgpICogeFxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGNsaXBUb0JveDogZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGFuaW1hdGlvbi5jbGlwLnJpZ2h0IC0gYW5pbWF0aW9uLmNsaXAubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFuaW1hdGlvbi5jbGlwLmJvdHRvbSAtIGFuaW1hdGlvbi5jbGlwLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBhbmltYXRpb24uY2xpcC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogYW5pbWF0aW9uLmNsaXAudG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEluamVjdHMgcmVjZW50bHkgcXVldWVkIGZ1bmN0aW9ucyB0byBiZSBmaXJzdCBpbiBsaW5lIChhZnRlciBcImlucHJvZ3Jlc3NcIilcbiAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24oIGVsZW1lbnQsIHF1ZXVlTGVuZ3RoLCBjb3VudCApIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IGVsZW1lbnQucXVldWUoKTtcblxuICAgICAgICAgICAgaWYgKCBxdWV1ZUxlbmd0aCA+IDEgKSB7XG4gICAgICAgICAgICAgICAgcXVldWUuc3BsaWNlLmFwcGx5KCBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgWyAxLCAwIF0uY29uY2F0KCBxdWV1ZS5zcGxpY2UoIHF1ZXVlTGVuZ3RoLCBjb3VudCApICkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuZGVxdWV1ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmVTdHlsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICBlbGVtZW50LmRhdGEoIGRhdGFTcGFjZVN0eWxlLCBlbGVtZW50WyAwIF0uc3R5bGUuY3NzVGV4dCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG4gICAgICAgICAgICBlbGVtZW50WyAwIF0uc3R5bGUuY3NzVGV4dCA9IGVsZW1lbnQuZGF0YSggZGF0YVNwYWNlU3R5bGUgKSB8fCBcIlwiO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVEYXRhKCBkYXRhU3BhY2VTdHlsZSApO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vZGU6IGZ1bmN0aW9uKCBlbGVtZW50LCBtb2RlICkge1xuICAgICAgICAgICAgdmFyIGhpZGRlbiA9IGVsZW1lbnQuaXMoIFwiOmhpZGRlblwiICk7XG5cbiAgICAgICAgICAgIGlmICggbW9kZSA9PT0gXCJ0b2dnbGVcIiApIHtcbiAgICAgICAgICAgICAgICBtb2RlID0gaGlkZGVuID8gXCJzaG93XCIgOiBcImhpZGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggaGlkZGVuID8gbW9kZSA9PT0gXCJoaWRlXCIgOiBtb2RlID09PSBcInNob3dcIiApIHtcbiAgICAgICAgICAgICAgICBtb2RlID0gXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUcmFuc2xhdGVzIGEgW3RvcCxsZWZ0XSBhcnJheSBpbnRvIGEgYmFzZWxpbmUgdmFsdWVcbiAgICAgICAgZ2V0QmFzZWxpbmU6IGZ1bmN0aW9uKCBvcmlnaW4sIG9yaWdpbmFsICkge1xuICAgICAgICAgICAgdmFyIHksIHg7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIG9yaWdpblsgMCBdICkge1xuICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICAgICAgICAgIHkgPSAwLjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgeSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHkgPSBvcmlnaW5bIDAgXSAvIG9yaWdpbmFsLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICggb3JpZ2luWyAxIF0gKSB7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgIHggPSAwLjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICB4ID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeCA9IG9yaWdpblsgMSBdIC8gb3JpZ2luYWwud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENyZWF0ZXMgYSBwbGFjZWhvbGRlciBlbGVtZW50IHNvIHRoYXQgdGhlIG9yaWdpbmFsIGVsZW1lbnQgY2FuIGJlIG1hZGUgYWJzb2x1dGVcbiAgICAgICAgY3JlYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIGNzc1Bvc2l0aW9uID0gZWxlbWVudC5jc3MoIFwicG9zaXRpb25cIiApLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZWxlbWVudC5wb3NpdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBMb2NrIGluIG1hcmdpbnMgZmlyc3QgdG8gYWNjb3VudCBmb3IgZm9ybSBlbGVtZW50cywgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2hhbmdlIG1hcmdpbiBpZiB5b3UgZXhwbGljaXRseSBzZXQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBzZWU6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvSlpTTXQvMy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwNzM4MFxuICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpXG4gICAgICAgICAgICBlbGVtZW50LmNzcygge1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogZWxlbWVudC5jc3MoIFwibWFyZ2luVG9wXCIgKSxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IGVsZW1lbnQuY3NzKCBcIm1hcmdpbkJvdHRvbVwiICksXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogZWxlbWVudC5jc3MoIFwibWFyZ2luTGVmdFwiICksXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IGVsZW1lbnQuY3NzKCBcIm1hcmdpblJpZ2h0XCIgKVxuICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAub3V0ZXJXaWR0aCggZWxlbWVudC5vdXRlcldpZHRoKCkgKVxuICAgICAgICAgICAgLm91dGVySGVpZ2h0KCBlbGVtZW50Lm91dGVySGVpZ2h0KCkgKTtcblxuICAgICAgICAgICAgaWYgKCAvXihzdGF0aWN8cmVsYXRpdmUpLy50ZXN0KCBjc3NQb3NpdGlvbiApICkge1xuICAgICAgICAgICAgICAgIGNzc1Bvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSAkKCBcIjxcIiArIGVsZW1lbnRbIDAgXS5ub2RlTmFtZSArIFwiPlwiICkuaW5zZXJ0QWZ0ZXIoIGVsZW1lbnQgKS5jc3MoIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGlubGluZSB0byBpbmxpbmUgYmxvY2sgdG8gYWNjb3VudCBmb3IgaW5saW5lIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgdHVybiB0byBpbmxpbmUgYmxvY2sgYmFzZWQgb24gY29udGVudCAobGlrZSBpbWcpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IC9eKGlubGluZXxydWJ5KS8udGVzdCggZWxlbWVudC5jc3MoIFwiZGlzcGxheVwiICkgKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBcImlubGluZS1ibG9ja1wiIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJnaW5zIG5lZWQgdG8gYmUgc2V0IHRvIGFjY291bnQgZm9yIG1hcmdpbiBjb2xsYXBzZVxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGVsZW1lbnQuY3NzKCBcIm1hcmdpblRvcFwiICksXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogZWxlbWVudC5jc3MoIFwibWFyZ2luQm90dG9tXCIgKSxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogZWxlbWVudC5jc3MoIFwibWFyZ2luTGVmdFwiICksXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBlbGVtZW50LmNzcyggXCJtYXJnaW5SaWdodFwiICksXG4gICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogZWxlbWVudC5jc3MoIFwiZmxvYXRcIiApXG4gICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAgICAgLm91dGVyV2lkdGgoIGVsZW1lbnQub3V0ZXJXaWR0aCgpIClcbiAgICAgICAgICAgICAgICAub3V0ZXJIZWlnaHQoIGVsZW1lbnQub3V0ZXJIZWlnaHQoKSApXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCBcInVpLWVmZmVjdHMtcGxhY2Vob2xkZXJcIiApO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhKCBkYXRhU3BhY2UgKyBcInBsYWNlaG9sZGVyXCIsIHBsYWNlaG9sZGVyICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQuY3NzKCB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGNzc1Bvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3BcbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVBsYWNlaG9sZGVyOiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgIHZhciBkYXRhS2V5ID0gZGF0YVNwYWNlICsgXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IGVsZW1lbnQuZGF0YSggZGF0YUtleSApO1xuXG4gICAgICAgICAgICBpZiAoIHBsYWNlaG9sZGVyICkge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRGF0YSggZGF0YUtleSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJlbW92ZXMgYSBwbGFjZWhvbGRlciBpZiBpdCBleGlzdHMgYW5kIHJlc3RvcmVzXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhhdCB3ZXJlIG1vZGlmaWVkIGR1cmluZyBwbGFjZWhvbGRlciBjcmVhdGlvblxuICAgICAgICBjbGVhblVwOiBmdW5jdGlvbiggZWxlbWVudCApIHtcbiAgICAgICAgICAgICQuZWZmZWN0cy5yZXN0b3JlU3R5bGUoIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICQuZWZmZWN0cy5yZW1vdmVQbGFjZWhvbGRlciggZWxlbWVudCApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKCBlbGVtZW50LCBsaXN0LCBmYWN0b3IsIHZhbHVlICkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB7fTtcbiAgICAgICAgICAgICQuZWFjaCggbGlzdCwgZnVuY3Rpb24oIGksIHggKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuaXQgPSBlbGVtZW50LmNzc1VuaXQoIHggKTtcbiAgICAgICAgICAgICAgICBpZiAoIHVuaXRbIDAgXSA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWyB4IF0gPSB1bml0WyAwIF0gKiBmYWN0b3IgKyB1bml0WyAxIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfSApO1xuXG4gICAgLy8gUmV0dXJuIGFuIGVmZmVjdCBvcHRpb25zIG9iamVjdCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnM6XG4gICAgZnVuY3Rpb24gX25vcm1hbGl6ZUFyZ3VtZW50cyggZWZmZWN0LCBvcHRpb25zLCBzcGVlZCwgY2FsbGJhY2sgKSB7XG5cbiAgICAgICAgLy8gQWxsb3cgcGFzc2luZyBhbGwgb3B0aW9ucyBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gICAgICAgIGlmICggJC5pc1BsYWluT2JqZWN0KCBlZmZlY3QgKSApIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlZmZlY3Q7XG4gICAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QuZWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB0byBhbiBvYmplY3RcbiAgICAgICAgZWZmZWN0ID0geyBlZmZlY3Q6IGVmZmVjdCB9O1xuXG4gICAgICAgIC8vIENhdGNoIChlZmZlY3QsIG51bGwsIC4uLilcbiAgICAgICAgaWYgKCBvcHRpb25zID09IG51bGwgKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXRjaCAoZWZmZWN0LCBjYWxsYmFjaylcbiAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIHNwZWVkID0gbnVsbDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhdGNoIChlZmZlY3QsIHNwZWVkLCA/KVxuICAgICAgICBpZiAoIHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiIHx8ICQuZnguc3BlZWRzWyBvcHRpb25zIF0gKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHNwZWVkO1xuICAgICAgICAgICAgc3BlZWQgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2F0Y2ggKGVmZmVjdCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBzcGVlZCApICkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzcGVlZDtcbiAgICAgICAgICAgIHNwZWVkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBvcHRpb25zIHRvIGVmZmVjdFxuICAgICAgICBpZiAoIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAkLmV4dGVuZCggZWZmZWN0LCBvcHRpb25zICk7XG4gICAgICAgIH1cblxuICAgICAgICBzcGVlZCA9IHNwZWVkIHx8IG9wdGlvbnMuZHVyYXRpb247XG4gICAgICAgIGVmZmVjdC5kdXJhdGlvbiA9ICQuZngub2ZmID8gMCA6XG4gICAgICAgICAgICB0eXBlb2Ygc3BlZWQgPT09IFwibnVtYmVyXCIgPyBzcGVlZCA6XG4gICAgICAgICAgICBzcGVlZCBpbiAkLmZ4LnNwZWVkcyA/ICQuZnguc3BlZWRzWyBzcGVlZCBdIDpcbiAgICAgICAgICAgICQuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG4gICAgICAgIGVmZmVjdC5jb21wbGV0ZSA9IGNhbGxiYWNrIHx8IG9wdGlvbnMuY29tcGxldGU7XG5cbiAgICAgICAgcmV0dXJuIGVmZmVjdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbiggb3B0aW9uICkge1xuXG4gICAgICAgIC8vIFZhbGlkIHN0YW5kYXJkIHNwZWVkcyAobm90aGluZywgbnVtYmVyLCBuYW1lZCBzcGVlZClcbiAgICAgICAgaWYgKCAhb3B0aW9uIHx8IHR5cGVvZiBvcHRpb24gPT09IFwibnVtYmVyXCIgfHwgJC5meC5zcGVlZHNbIG9wdGlvbiBdICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkIHN0cmluZ3MgLSB0cmVhdCBhcyBcIm5vcm1hbFwiIHNwZWVkXG4gICAgICAgIGlmICggdHlwZW9mIG9wdGlvbiA9PT0gXCJzdHJpbmdcIiAmJiAhJC5lZmZlY3RzLmVmZmVjdFsgb3B0aW9uIF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBsZXRlIGNhbGxiYWNrXG4gICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBvcHRpb24gKSApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3B0aW9ucyBoYXNoIChidXQgbm90IG5hbWluZyBhbiBlZmZlY3QpXG4gICAgICAgIGlmICggdHlwZW9mIG9wdGlvbiA9PT0gXCJvYmplY3RcIiAmJiAhb3B0aW9uLmVmZmVjdCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlkbid0IG1hdGNoIGFueSBzdGFuZGFyZCBBUElcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgICQuZm4uZXh0ZW5kKCB7XG4gICAgICAgIGVmZmVjdDogZnVuY3Rpb24oIC8qIGVmZmVjdCwgb3B0aW9ucywgc3BlZWQsIGNhbGxiYWNrICovICkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSxcbiAgICAgICAgICAgICAgICBlZmZlY3RNZXRob2QgPSAkLmVmZmVjdHMuZWZmZWN0WyBhcmdzLmVmZmVjdCBdLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRNb2RlID0gZWZmZWN0TWV0aG9kLm1vZGUsXG4gICAgICAgICAgICAgICAgcXVldWUgPSBhcmdzLnF1ZXVlLFxuICAgICAgICAgICAgICAgIHF1ZXVlTmFtZSA9IHF1ZXVlIHx8IFwiZnhcIixcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGFyZ3MuY29tcGxldGUsXG4gICAgICAgICAgICAgICAgbW9kZSA9IGFyZ3MubW9kZSxcbiAgICAgICAgICAgICAgICBtb2RlcyA9IFtdLFxuICAgICAgICAgICAgICAgIHByZWZpbHRlciA9IGZ1bmN0aW9uKCBuZXh0ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKCB0aGlzICksXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkTW9kZSA9ICQuZWZmZWN0cy5tb2RlKCBlbCwgbW9kZSApIHx8IGRlZmF1bHRNb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbnRpbmVsIGZvciBkdWNrLXB1bmNoaW5nIHRoZSA6YW5pbWF0ZWQgcHN1ZWRvLXNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIGVsLmRhdGEoIGRhdGFTcGFjZUFuaW1hdGVkLCB0cnVlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBlZmZlY3QgbW9kZSBmb3IgbGF0ZXIgdXNlLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBqdXN0IGNhbGwgJC5lZmZlY3RzLm1vZGUgYWdhaW4gbGF0ZXIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSAuc2hvdygpIGJlbG93IGRlc3Ryb3lzIHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIG1vZGVzLnB1c2goIG5vcm1hbGl6ZWRNb2RlICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlICQudWlCYWNrQ29tcGF0IGluc2lkZSBvZiBydW4oKSBmb3IgcmVtb3ZhbCBvZiBkZWZhdWx0TW9kZSBpbiAxLjEzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVmYXVsdE1vZGUgJiYgKCBub3JtYWxpemVkTW9kZSA9PT0gXCJzaG93XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIG5vcm1hbGl6ZWRNb2RlID09PSBkZWZhdWx0TW9kZSAmJiBub3JtYWxpemVkTW9kZSA9PT0gXCJoaWRlXCIgKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhZGVmYXVsdE1vZGUgfHwgbm9ybWFsaXplZE1vZGUgIT09IFwibm9uZVwiICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lZmZlY3RzLnNhdmVTdHlsZSggZWwgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggJC5pc0Z1bmN0aW9uKCBuZXh0ICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoICQuZngub2ZmIHx8ICFlZmZlY3RNZXRob2QgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgb3JpZ2luYWwgbWV0aG9kIChlLmcuLCAuc2hvdygpKSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIGlmICggbW9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbIG1vZGUgXSggYXJncy5kdXJhdGlvbiwgY29tcGxldGUgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29tcGxldGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUuY2FsbCggdGhpcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBydW4oIG5leHQgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSAkKCB0aGlzICk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZURhdGEoIGRhdGFTcGFjZUFuaW1hdGVkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgJC5lZmZlY3RzLmNsZWFuVXAoIGVsZW0gKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIGFyZ3MubW9kZSA9PT0gXCJoaWRlXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICQuaXNGdW5jdGlvbiggY29tcGxldGUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlLmNhbGwoIGVsZW1bIDAgXSApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIG5leHQgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1vZGUgb3B0aW9uIG9uIGEgcGVyIGVsZW1lbnQgYmFzaXMsXG4gICAgICAgICAgICAgICAgLy8gYXMgdG9nZ2xlIGNhbiBiZSBlaXRoZXIgc2hvdyBvciBoaWRlIGRlcGVuZGluZyBvbiBlbGVtZW50IHN0YXRlXG4gICAgICAgICAgICAgICAgYXJncy5tb2RlID0gbW9kZXMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICggJC51aUJhY2tDb21wYXQgIT09IGZhbHNlICYmICFkZWZhdWx0TW9kZSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlbGVtLmlzKCBcIjpoaWRkZW5cIiApID8gbW9kZSA9PT0gXCJoaWRlXCIgOiBtb2RlID09PSBcInNob3dcIiApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY29yZSBtZXRob2QgdG8gdHJhY2sgXCJvbGRkaXNwbGF5XCIgcHJvcGVybHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bIG1vZGUgXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0TWV0aG9kLmNhbGwoIGVsZW1bIDAgXSwgYXJncywgZG9uZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcmdzLm1vZGUgPT09IFwibm9uZVwiICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjb3JlIG1ldGhvZCB0byB0cmFjayBcIm9sZGRpc3BsYXlcIiBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsgbW9kZSBdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3RNZXRob2QuY2FsbCggZWxlbVsgMCBdLCBhcmdzLCBjbGVhbnVwICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJ1biBwcmVmaWx0ZXIgb24gYWxsIGVsZW1lbnRzIGZpcnN0IHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAgICAvLyBhbnkgc2hvd2luZyBvciBoaWRpbmcgaGFwcGVucyBiZWZvcmUgcGxhY2Vob2xkZXIgY3JlYXRpb24sXG4gICAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgYW55IGxheW91dCBjaGFuZ2VzIGFyZSBjb3JyZWN0bHkgY2FwdHVyZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVldWUgPT09IGZhbHNlID9cbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goIHByZWZpbHRlciApLmVhY2goIHJ1biApIDpcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlKCBxdWV1ZU5hbWUsIHByZWZpbHRlciApLnF1ZXVlKCBxdWV1ZU5hbWUsIHJ1biApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6ICggZnVuY3Rpb24oIG9yaWcgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKCBvcHRpb24gKSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MubW9kZSA9IFwic2hvd1wiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCggdGhpcywgYXJncyApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gKSggJC5mbi5zaG93ICksXG5cbiAgICAgICAgaGlkZTogKCBmdW5jdGlvbiggb3JpZyApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiggb3B0aW9uICkge1xuICAgICAgICAgICAgICAgIGlmICggc3RhbmRhcmRBbmltYXRpb25PcHRpb24oIG9wdGlvbiApICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5tb2RlID0gXCJoaWRlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVmZmVjdC5jYWxsKCB0aGlzLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApKCAkLmZuLmhpZGUgKSxcblxuICAgICAgICB0b2dnbGU6ICggZnVuY3Rpb24oIG9yaWcgKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oIG9wdGlvbiApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKCBvcHRpb24gKSB8fCB0eXBlb2Ygb3B0aW9uID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MubW9kZSA9IFwidG9nZ2xlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVmZmVjdC5jYWxsKCB0aGlzLCBhcmdzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSApKCAkLmZuLnRvZ2dsZSApLFxuXG4gICAgICAgIGNzc1VuaXQ6IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmNzcygga2V5ICksXG4gICAgICAgICAgICAgICAgdmFsID0gW107XG5cbiAgICAgICAgICAgICQuZWFjaCggWyBcImVtXCIsIFwicHhcIiwgXCIlXCIsIFwicHRcIiBdLCBmdW5jdGlvbiggaSwgdW5pdCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHN0eWxlLmluZGV4T2YoIHVuaXQgKSA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IFsgcGFyc2VGbG9hdCggc3R5bGUgKSwgdW5pdCBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3NzQ2xpcDogZnVuY3Rpb24oIGNsaXBPYmogKSB7XG4gICAgICAgICAgICBpZiAoIGNsaXBPYmogKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3NzKCBcImNsaXBcIiwgXCJyZWN0KFwiICsgY2xpcE9iai50b3AgKyBcInB4IFwiICsgY2xpcE9iai5yaWdodCArIFwicHggXCIgK1xuICAgICAgICAgICAgICAgICAgICBjbGlwT2JqLmJvdHRvbSArIFwicHggXCIgKyBjbGlwT2JqLmxlZnQgKyBcInB4KVwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VDbGlwKCB0aGlzLmNzcyggXCJjbGlwXCIgKSwgdGhpcyApO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zZmVyOiBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgICAgIHRhcmdldCA9ICQoIG9wdGlvbnMudG8gKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRGaXhlZCA9IHRhcmdldC5jc3MoIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgYm9keSA9ICQoIFwiYm9keVwiICksXG4gICAgICAgICAgICAgICAgZml4VG9wID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbFRvcCgpIDogMCxcbiAgICAgICAgICAgICAgICBmaXhMZWZ0ID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbExlZnQoKSA6IDAsXG4gICAgICAgICAgICAgICAgZW5kUG9zaXRpb24gPSB0YXJnZXQub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IGVuZFBvc2l0aW9uLnRvcCAtIGZpeFRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZW5kUG9zaXRpb24ubGVmdCAtIGZpeExlZnQsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGFyZ2V0LmlubmVySGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0YXJnZXQuaW5uZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gZWxlbWVudC5vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlciA9ICQoIFwiPGRpdiBjbGFzcz0ndWktZWZmZWN0cy10cmFuc2Zlcic+PC9kaXY+XCIgKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oIFwiYm9keVwiIClcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCBvcHRpb25zLmNsYXNzTmFtZSApXG4gICAgICAgICAgICAgICAgICAgIC5jc3MoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogc3RhcnRQb3NpdGlvbi50b3AgLSBmaXhUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzdGFydFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZWxlbWVudC5pbm5lcldpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGFyZ2V0Rml4ZWQgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCJcbiAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKCBhbmltYXRpb24sIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAkLmlzRnVuY3Rpb24oIGRvbmUgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2xpcCggc3RyLCBlbGVtZW50ICkge1xuICAgICAgICAgICAgdmFyIG91dGVyV2lkdGggPSBlbGVtZW50Lm91dGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICBvdXRlckhlaWdodCA9IGVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBjbGlwUmVnZXggPSAvXnJlY3RcXCgoLT9cXGQqXFwuP1xcZCpweHwtP1xcZCslfGF1dG8pLD9cXHMqKC0/XFxkKlxcLj9cXGQqcHh8LT9cXGQrJXxhdXRvKSw/XFxzKigtP1xcZCpcXC4/XFxkKnB4fC0/XFxkKyV8YXV0byksP1xccyooLT9cXGQqXFwuP1xcZCpweHwtP1xcZCslfGF1dG8pXFwpJC8sXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gY2xpcFJlZ2V4LmV4ZWMoIHN0ciApIHx8IFsgXCJcIiwgMCwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQsIDAgXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHBhcnNlRmxvYXQoIHZhbHVlc1sgMSBdICkgfHwgMCxcbiAgICAgICAgICAgICAgICByaWdodDogdmFsdWVzWyAyIF0gPT09IFwiYXV0b1wiID8gb3V0ZXJXaWR0aCA6IHBhcnNlRmxvYXQoIHZhbHVlc1sgMiBdICksXG4gICAgICAgICAgICAgICAgYm90dG9tOiB2YWx1ZXNbIDMgXSA9PT0gXCJhdXRvXCIgPyBvdXRlckhlaWdodCA6IHBhcnNlRmxvYXQoIHZhbHVlc1sgMyBdICksXG4gICAgICAgICAgICAgICAgbGVmdDogcGFyc2VGbG9hdCggdmFsdWVzWyA0IF0gKSB8fCAwXG4gICAgICAgICAgICB9O1xuICAgIH1cblxuICAgICQuZnguc3RlcC5jbGlwID0gZnVuY3Rpb24oIGZ4ICkge1xuICAgICAgICBpZiAoICFmeC5jbGlwSW5pdCApIHtcbiAgICAgICAgICAgIGZ4LnN0YXJ0ID0gJCggZnguZWxlbSApLmNzc0NsaXAoKTtcbiAgICAgICAgICAgIGlmICggdHlwZW9mIGZ4LmVuZCA9PT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAgICAgICBmeC5lbmQgPSBwYXJzZUNsaXAoIGZ4LmVuZCwgZnguZWxlbSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnguY2xpcEluaXQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgJCggZnguZWxlbSApLmNzc0NsaXAoIHtcbiAgICAgICAgICAgIHRvcDogZngucG9zICogKCBmeC5lbmQudG9wIC0gZnguc3RhcnQudG9wICkgKyBmeC5zdGFydC50b3AsXG4gICAgICAgICAgICByaWdodDogZngucG9zICogKCBmeC5lbmQucmlnaHQgLSBmeC5zdGFydC5yaWdodCApICsgZnguc3RhcnQucmlnaHQsXG4gICAgICAgICAgICBib3R0b206IGZ4LnBvcyAqICggZnguZW5kLmJvdHRvbSAtIGZ4LnN0YXJ0LmJvdHRvbSApICsgZnguc3RhcnQuYm90dG9tLFxuICAgICAgICAgICAgbGVmdDogZngucG9zICogKCBmeC5lbmQubGVmdCAtIGZ4LnN0YXJ0LmxlZnQgKSArIGZ4LnN0YXJ0LmxlZnRcbiAgICAgICAgfSApO1xuICAgIH07XG5cbiAgICB9ICkoKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVBU0lORyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgKCBmdW5jdGlvbigpIHtcblxuICAgIC8vIEJhc2VkIG9uIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxuXG4gICAgdmFyIGJhc2VFYXNpbmdzID0ge307XG5cbiAgICAkLmVhY2goIFsgXCJRdWFkXCIsIFwiQ3ViaWNcIiwgXCJRdWFydFwiLCBcIlF1aW50XCIsIFwiRXhwb1wiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuICAgICAgICBiYXNlRWFzaW5nc1sgbmFtZSBdID0gZnVuY3Rpb24oIHAgKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coIHAsIGkgKyAyICk7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgJC5leHRlbmQoIGJhc2VFYXNpbmdzLCB7XG4gICAgICAgIFNpbmU6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgLyAyICk7XG4gICAgICAgIH0sXG4gICAgICAgIENpcmM6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoIDEgLSBwICogcCApO1xuICAgICAgICB9LFxuICAgICAgICBFbGFzdGljOiBmdW5jdGlvbiggcCApIHtcbiAgICAgICAgICAgIHJldHVybiBwID09PSAwIHx8IHAgPT09IDEgPyBwIDpcbiAgICAgICAgICAgICAgICAtTWF0aC5wb3coIDIsIDggKiAoIHAgLSAxICkgKSAqIE1hdGguc2luKCAoICggcCAtIDEgKSAqIDgwIC0gNy41ICkgKiBNYXRoLlBJIC8gMTUgKTtcbiAgICAgICAgfSxcbiAgICAgICAgQmFjazogZnVuY3Rpb24oIHAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcCAqIHAgKiAoIDMgKiBwIC0gMiApO1xuICAgICAgICB9LFxuICAgICAgICBCb3VuY2U6IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgdmFyIHBvdzIsXG4gICAgICAgICAgICAgICAgYm91bmNlID0gNDtcblxuICAgICAgICAgICAgd2hpbGUgKCBwIDwgKCAoIHBvdzIgPSBNYXRoLnBvdyggMiwgLS1ib3VuY2UgKSApIC0gMSApIC8gMTEgKSB7fVxuICAgICAgICAgICAgcmV0dXJuIDEgLyBNYXRoLnBvdyggNCwgMyAtIGJvdW5jZSApIC0gNy41NjI1ICogTWF0aC5wb3coICggcG93MiAqIDMgLSAyICkgLyAyMiAtIHAsIDIgKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxuICAgICQuZWFjaCggYmFzZUVhc2luZ3MsIGZ1bmN0aW9uKCBuYW1lLCBlYXNlSW4gKSB7XG4gICAgICAgICQuZWFzaW5nWyBcImVhc2VJblwiICsgbmFtZSBdID0gZWFzZUluO1xuICAgICAgICAkLmVhc2luZ1sgXCJlYXNlT3V0XCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggcCApIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gZWFzZUluKCAxIC0gcCApO1xuICAgICAgICB9O1xuICAgICAgICAkLmVhc2luZ1sgXCJlYXNlSW5PdXRcIiArIG5hbWUgXSA9IGZ1bmN0aW9uKCBwICkge1xuICAgICAgICAgICAgcmV0dXJuIHAgPCAwLjUgP1xuICAgICAgICAgICAgICAgIGVhc2VJbiggcCAqIDIgKSAvIDIgOlxuICAgICAgICAgICAgICAgIDEgLSBlYXNlSW4oIHAgKiAtMiArIDIgKSAvIDI7XG4gICAgICAgIH07XG4gICAgfSApO1xuXG4gICAgfSApKCk7XG5cbiAgICB2YXIgZWZmZWN0ID0gJC5lZmZlY3RzO1xuXG5cbiAgICAvKiFcbiAgICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBCbGluZCAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IEJsaW5kIEVmZmVjdFxuICAgIC8vPj5ncm91cDogRWZmZWN0c1xuICAgIC8vPj5kZXNjcmlwdGlvbjogQmxpbmRzIHRoZSBlbGVtZW50LlxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9ibGluZC1lZmZlY3QvXG4gICAgLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbiAgICB2YXIgZWZmZWN0c0VmZmVjdEJsaW5kID0gJC5lZmZlY3RzLmRlZmluZSggXCJibGluZFwiLCBcImhpZGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG4gICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAgICAgdXA6IFsgXCJib3R0b21cIiwgXCJ0b3BcIiBdLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBbIFwiYm90dG9tXCIsIFwidG9wXCIgXSxcbiAgICAgICAgICAgICAgICBkb3duOiBbIFwidG9wXCIsIFwiYm90dG9tXCIgXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBbIFwicmlnaHRcIiwgXCJsZWZ0XCIgXSxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsOiBbIFwicmlnaHRcIiwgXCJsZWZ0XCIgXSxcbiAgICAgICAgICAgICAgICByaWdodDogWyBcImxlZnRcIiwgXCJyaWdodFwiIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbGVtZW50ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgXCJ1cFwiLFxuICAgICAgICAgICAgc3RhcnQgPSBlbGVtZW50LmNzc0NsaXAoKSxcbiAgICAgICAgICAgIGFuaW1hdGUgPSB7IGNsaXA6ICQuZXh0ZW5kKCB7fSwgc3RhcnQgKSB9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSAkLmVmZmVjdHMuY3JlYXRlUGxhY2Vob2xkZXIoIGVsZW1lbnQgKTtcblxuICAgICAgICBhbmltYXRlLmNsaXBbIG1hcFsgZGlyZWN0aW9uIF1bIDAgXSBdID0gYW5pbWF0ZS5jbGlwWyBtYXBbIGRpcmVjdGlvbiBdWyAxIF0gXTtcblxuICAgICAgICBpZiAoIG9wdGlvbnMubW9kZSA9PT0gXCJzaG93XCIgKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNzc0NsaXAoIGFuaW1hdGUuY2xpcCApO1xuICAgICAgICAgICAgaWYgKCBwbGFjZWhvbGRlciApIHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlci5jc3MoICQuZWZmZWN0cy5jbGlwVG9Cb3goIGFuaW1hdGUgKSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmltYXRlLmNsaXAgPSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcGxhY2Vob2xkZXIgKSB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5hbmltYXRlKCAkLmVmZmVjdHMuY2xpcFRvQm94KCBhbmltYXRlICksIG9wdGlvbnMuZHVyYXRpb24sIG9wdGlvbnMuZWFzaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmFuaW1hdGUoIGFuaW1hdGUsIHtcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBkb25lXG4gICAgICAgIH0gKTtcbiAgICB9ICk7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIEJvdW5jZSAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IEJvdW5jZSBFZmZlY3RcbiAgICAvLz4+Z3JvdXA6IEVmZmVjdHNcbiAgICAvLz4+ZGVzY3JpcHRpb246IEJvdW5jZXMgYW4gZWxlbWVudCBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseSBuIHRpbWVzLlxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9ib3VuY2UtZWZmZWN0L1xuICAgIC8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG4gICAgdmFyIGVmZmVjdHNFZmZlY3RCb3VuY2UgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImJvdW5jZVwiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcbiAgICAgICAgdmFyIHVwQW5pbSwgZG93bkFuaW0sIHJlZlZhbHVlLFxuICAgICAgICAgICAgZWxlbWVudCA9ICQoIHRoaXMgKSxcblxuICAgICAgICAgICAgLy8gRGVmYXVsdHM6XG4gICAgICAgICAgICBtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgICAgaGlkZSA9IG1vZGUgPT09IFwiaGlkZVwiLFxuICAgICAgICAgICAgc2hvdyA9IG1vZGUgPT09IFwic2hvd1wiLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgXCJ1cFwiLFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlLFxuICAgICAgICAgICAgdGltZXMgPSBvcHRpb25zLnRpbWVzIHx8IDUsXG5cbiAgICAgICAgICAgIC8vIE51bWJlciBvZiBpbnRlcm5hbCBhbmltYXRpb25zXG4gICAgICAgICAgICBhbmltcyA9IHRpbWVzICogMiArICggc2hvdyB8fCBoaWRlID8gMSA6IDAgKSxcbiAgICAgICAgICAgIHNwZWVkID0gb3B0aW9ucy5kdXJhdGlvbiAvIGFuaW1zLFxuICAgICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcsXG5cbiAgICAgICAgICAgIC8vIFV0aWxpdHk6XG4gICAgICAgICAgICByZWYgPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgKSA/IFwidG9wXCIgOiBcImxlZnRcIixcbiAgICAgICAgICAgIG1vdGlvbiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiApLFxuICAgICAgICAgICAgaSA9IDAsXG5cbiAgICAgICAgICAgIHF1ZXVlbGVuID0gZWxlbWVudC5xdWV1ZSgpLmxlbmd0aDtcblxuICAgICAgICAkLmVmZmVjdHMuY3JlYXRlUGxhY2Vob2xkZXIoIGVsZW1lbnQgKTtcblxuICAgICAgICByZWZWYWx1ZSA9IGVsZW1lbnQuY3NzKCByZWYgKTtcblxuICAgICAgICAvLyBEZWZhdWx0IGRpc3RhbmNlIGZvciB0aGUgQklHR0VTVCBib3VuY2UgaXMgdGhlIG91dGVyIERpc3RhbmNlIC8gM1xuICAgICAgICBpZiAoICFkaXN0YW5jZSApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gZWxlbWVudFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSgpIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc2hvdyApIHtcbiAgICAgICAgICAgIGRvd25BbmltID0geyBvcGFjaXR5OiAxIH07XG4gICAgICAgICAgICBkb3duQW5pbVsgcmVmIF0gPSByZWZWYWx1ZTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHNob3dpbmcsIGZvcmNlIG9wYWNpdHkgMCBhbmQgc2V0IHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyB0aGVuIGRvIHRoZSBcImZpcnN0XCIgYW5pbWF0aW9uXG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgLmNzcyggXCJvcGFjaXR5XCIsIDAgKVxuICAgICAgICAgICAgICAgIC5jc3MoIHJlZiwgbW90aW9uID8gLWRpc3RhbmNlICogMiA6IGRpc3RhbmNlICogMiApXG4gICAgICAgICAgICAgICAgLmFuaW1hdGUoIGRvd25BbmltLCBzcGVlZCwgZWFzaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCBhdCB0aGUgc21hbGxlc3QgZGlzdGFuY2UgaWYgd2UgYXJlIGhpZGluZ1xuICAgICAgICBpZiAoIGhpZGUgKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlIC8gTWF0aC5wb3coIDIsIHRpbWVzIC0gMSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZG93bkFuaW0gPSB7fTtcbiAgICAgICAgZG93bkFuaW1bIHJlZiBdID0gcmVmVmFsdWU7XG5cbiAgICAgICAgLy8gQm91bmNlcyB1cC9kb3duL2xlZnQvcmlnaHQgdGhlbiBiYWNrIHRvIDAgLS0gdGltZXMgKiAyIGFuaW1hdGlvbnMgaGFwcGVuIGhlcmVcbiAgICAgICAgZm9yICggOyBpIDwgdGltZXM7IGkrKyApIHtcbiAgICAgICAgICAgIHVwQW5pbSA9IHt9O1xuICAgICAgICAgICAgdXBBbmltWyByZWYgXSA9ICggbW90aW9uID8gXCItPVwiIDogXCIrPVwiICkgKyBkaXN0YW5jZTtcblxuICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAgIC5hbmltYXRlKCB1cEFuaW0sIHNwZWVkLCBlYXNpbmcgKVxuICAgICAgICAgICAgICAgIC5hbmltYXRlKCBkb3duQW5pbSwgc3BlZWQsIGVhc2luZyApO1xuXG4gICAgICAgICAgICBkaXN0YW5jZSA9IGhpZGUgPyBkaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYXN0IEJvdW5jZSB3aGVuIEhpZGluZ1xuICAgICAgICBpZiAoIGhpZGUgKSB7XG4gICAgICAgICAgICB1cEFuaW0gPSB7IG9wYWNpdHk6IDAgfTtcbiAgICAgICAgICAgIHVwQW5pbVsgcmVmIF0gPSAoIG1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuYW5pbWF0ZSggdXBBbmltLCBzcGVlZCwgZWFzaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnF1ZXVlKCBkb25lICk7XG5cbiAgICAgICAgJC5lZmZlY3RzLnVuc2hpZnQoIGVsZW1lbnQsIHF1ZXVlbGVuLCBhbmltcyArIDEgKTtcbiAgICB9ICk7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIENsaXAgMS4xMi4xXG4gICAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqL1xuXG4gICAgLy8+PmxhYmVsOiBDbGlwIEVmZmVjdFxuICAgIC8vPj5ncm91cDogRWZmZWN0c1xuICAgIC8vPj5kZXNjcmlwdGlvbjogQ2xpcHMgdGhlIGVsZW1lbnQgb24gYW5kIG9mZiBsaWtlIGFuIG9sZCBUVi5cbiAgICAvLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2xpcC1lZmZlY3QvXG4gICAgLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbiAgICB2YXIgZWZmZWN0c0VmZmVjdENsaXAgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImNsaXBcIiwgXCJoaWRlXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuICAgICAgICB2YXIgc3RhcnQsXG4gICAgICAgICAgICBhbmltYXRlID0ge30sXG4gICAgICAgICAgICBlbGVtZW50ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgXCJ2ZXJ0aWNhbFwiLFxuICAgICAgICAgICAgYm90aCA9IGRpcmVjdGlvbiA9PT0gXCJib3RoXCIsXG4gICAgICAgICAgICBob3Jpem9udGFsID0gYm90aCB8fCBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICAgICAgdmVydGljYWwgPSBib3RoIHx8IGRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgICAgIHN0YXJ0ID0gZWxlbWVudC5jc3NDbGlwKCk7XG4gICAgICAgIGFuaW1hdGUuY2xpcCA9IHtcbiAgICAgICAgICAgIHRvcDogdmVydGljYWwgPyAoIHN0YXJ0LmJvdHRvbSAtIHN0YXJ0LnRvcCApIC8gMiA6IHN0YXJ0LnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiBob3Jpem9udGFsID8gKCBzdGFydC5yaWdodCAtIHN0YXJ0LmxlZnQgKSAvIDIgOiBzdGFydC5yaWdodCxcbiAgICAgICAgICAgIGJvdHRvbTogdmVydGljYWwgPyAoIHN0YXJ0LmJvdHRvbSAtIHN0YXJ0LnRvcCApIC8gMiA6IHN0YXJ0LmJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQ6IGhvcml6b250YWwgPyAoIHN0YXJ0LnJpZ2h0IC0gc3RhcnQubGVmdCApIC8gMiA6IHN0YXJ0LmxlZnRcbiAgICAgICAgfTtcblxuICAgICAgICAkLmVmZmVjdHMuY3JlYXRlUGxhY2Vob2xkZXIoIGVsZW1lbnQgKTtcblxuICAgICAgICBpZiAoIG9wdGlvbnMubW9kZSA9PT0gXCJzaG93XCIgKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNzc0NsaXAoIGFuaW1hdGUuY2xpcCApO1xuICAgICAgICAgICAgYW5pbWF0ZS5jbGlwID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmFuaW1hdGUoIGFuaW1hdGUsIHtcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBkb25lXG4gICAgICAgIH0gKTtcblxuICAgIH0gKTtcblxuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IFVJIEVmZmVjdHMgRHJvcCAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IERyb3AgRWZmZWN0XG4gICAgLy8+Pmdyb3VwOiBFZmZlY3RzXG4gICAgLy8+PmRlc2NyaXB0aW9uOiBNb3ZlcyBhbiBlbGVtZW50IGluIG9uZSBkaXJlY3Rpb24gYW5kIGhpZGVzIGl0IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2Ryb3AtZWZmZWN0L1xuICAgIC8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG4gICAgdmFyIGVmZmVjdHNFZmZlY3REcm9wID0gJC5lZmZlY3RzLmRlZmluZSggXCJkcm9wXCIsIFwiaGlkZVwiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcblxuICAgICAgICB2YXIgZGlzdGFuY2UsXG4gICAgICAgICAgICBlbGVtZW50ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgIHNob3cgPSBtb2RlID09PSBcInNob3dcIixcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8IFwibGVmdFwiLFxuICAgICAgICAgICAgcmVmID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiICkgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBtb3Rpb24gPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgKSA/IFwiLT1cIiA6IFwiKz1cIixcbiAgICAgICAgICAgIG9wcG9zaXRlTW90aW9uID0gKCBtb3Rpb24gPT09IFwiKz1cIiApID8gXCItPVwiIDogXCIrPVwiLFxuICAgICAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgJC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cbiAgICAgICAgZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlIHx8XG4gICAgICAgICAgICBlbGVtZW50WyByZWYgPT09IFwidG9wXCIgPyBcIm91dGVySGVpZ2h0XCIgOiBcIm91dGVyV2lkdGhcIiBdKCB0cnVlICkgLyAyO1xuXG4gICAgICAgIGFuaW1hdGlvblsgcmVmIF0gPSBtb3Rpb24gKyBkaXN0YW5jZTtcblxuICAgICAgICBpZiAoIHNob3cgKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNzcyggYW5pbWF0aW9uICk7XG5cbiAgICAgICAgICAgIGFuaW1hdGlvblsgcmVmIF0gPSBvcHBvc2l0ZU1vdGlvbiArIGRpc3RhbmNlO1xuICAgICAgICAgICAgYW5pbWF0aW9uLm9wYWNpdHkgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5pbWF0ZVxuICAgICAgICBlbGVtZW50LmFuaW1hdGUoIGFuaW1hdGlvbiwge1xuICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgICAgICAgY29tcGxldGU6IGRvbmVcbiAgICAgICAgfSApO1xuICAgIH0gKTtcblxuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IFVJIEVmZmVjdHMgRXhwbG9kZSAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IEV4cGxvZGUgRWZmZWN0XG4gICAgLy8+Pmdyb3VwOiBFZmZlY3RzXG4gICAgLy8ganNjczpkaXNhYmxlIG1heGltdW1MaW5lTGVuZ3RoXG4gICAgLy8+PmRlc2NyaXB0aW9uOiBFeHBsb2RlcyBhbiBlbGVtZW50IGluIGFsbCBkaXJlY3Rpb25zIGludG8gbiBwaWVjZXMuIEltcGxvZGVzIGFuIGVsZW1lbnQgdG8gaXRzIG9yaWdpbmFsIHdob2xlbmVzcy5cbiAgICAvLyBqc2NzOmVuYWJsZSBtYXhpbXVtTGluZUxlbmd0aFxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9leHBsb2RlLWVmZmVjdC9cbiAgICAvLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxuICAgIHZhciBlZmZlY3RzRWZmZWN0RXhwbG9kZSA9ICQuZWZmZWN0cy5kZWZpbmUoIFwiZXhwbG9kZVwiLCBcImhpZGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cbiAgICAgICAgdmFyIGksIGosIGxlZnQsIHRvcCwgbXgsIG15LFxuICAgICAgICAgICAgcm93cyA9IG9wdGlvbnMucGllY2VzID8gTWF0aC5yb3VuZCggTWF0aC5zcXJ0KCBvcHRpb25zLnBpZWNlcyApICkgOiAzLFxuICAgICAgICAgICAgY2VsbHMgPSByb3dzLFxuICAgICAgICAgICAgZWxlbWVudCA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgIG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgICBzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG5cbiAgICAgICAgICAgIC8vIFNob3cgYW5kIHRoZW4gdmlzaWJpbGl0eTpoaWRkZW4gdGhlIGVsZW1lbnQgYmVmb3JlIGNhbGN1bGF0aW5nIG9mZnNldFxuICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbWVudC5zaG93KCkuY3NzKCBcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIiApLm9mZnNldCgpLFxuXG4gICAgICAgICAgICAvLyBXaWR0aCBhbmQgaGVpZ2h0IG9mIGEgcGllY2VcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKCBlbGVtZW50Lm91dGVyV2lkdGgoKSAvIGNlbGxzICksXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoIGVsZW1lbnQub3V0ZXJIZWlnaHQoKSAvIHJvd3MgKSxcbiAgICAgICAgICAgIHBpZWNlcyA9IFtdO1xuXG4gICAgICAgIC8vIENoaWxkcmVuIGFuaW1hdGUgY29tcGxldGU6XG4gICAgICAgIGZ1bmN0aW9uIGNoaWxkQ29tcGxldGUoKSB7XG4gICAgICAgICAgICBwaWVjZXMucHVzaCggdGhpcyApO1xuICAgICAgICAgICAgaWYgKCBwaWVjZXMubGVuZ3RoID09PSByb3dzICogY2VsbHMgKSB7XG4gICAgICAgICAgICAgICAgYW5pbUNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9uZSB0aGUgZWxlbWVudCBmb3IgZWFjaCByb3cgYW5kIGNlbGwuXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcm93czsgaSsrICkgeyAvLyA9PT0+XG4gICAgICAgICAgICB0b3AgPSBvZmZzZXQudG9wICsgaSAqIGhlaWdodDtcbiAgICAgICAgICAgIG15ID0gaSAtICggcm93cyAtIDEgKSAvIDI7XG5cbiAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgY2VsbHM7IGorKyApIHsgLy8gfHx8XG4gICAgICAgICAgICAgICAgbGVmdCA9IG9mZnNldC5sZWZ0ICsgaiAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIG14ID0gaiAtICggY2VsbHMgLSAxICkgLyAyO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIG5vdyBoaWRkZW4gbWFpbiBlbGVtZW50IHRoYXQgd2lsbCBiZSBhYnNvbHV0ZSBwb3NpdGlvbmVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGEgd3JhcHBlciBkaXYgb2ZmIHRoZSAtbGVmdCBhbmQgLXRvcCBlcXVhbCB0byBzaXplIG9mIG91ciBwaWVjZXNcbiAgICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC5jbG9uZSgpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyggXCJib2R5XCIgKVxuICAgICAgICAgICAgICAgICAgICAud3JhcCggXCI8ZGl2PjwvZGl2PlwiIClcbiAgICAgICAgICAgICAgICAgICAgLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogLWogKiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogLWkgKiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSApXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSB3cmFwcGVyIC0gbWFrZSBpdCBvdmVyZmxvdzogaGlkZGVuIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmVkIGJhc2VkIG9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIHRoZSBvcmlnaW5hbCB3YXMgbG9jYXRlZCArbGVmdCBhbmQgK3RvcCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBwaWVjZXNcbiAgICAgICAgICAgICAgICAgICAgLnBhcmVudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoIFwidWktZWZmZWN0cy1leHBsb2RlXCIgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQgKyAoIHNob3cgPyBteCAqIHdpZHRoIDogMCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogdG9wICsgKCBzaG93ID8gbXkgKiBoZWlnaHQgOiAwICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogc2hvdyA/IDAgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9IClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGVmdCArICggc2hvdyA/IDAgOiBteCAqIHdpZHRoICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AgKyAoIHNob3cgPyAwIDogbXkgKiBoZWlnaHQgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBzaG93ID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuZHVyYXRpb24gfHwgNTAwLCBvcHRpb25zLmVhc2luZywgY2hpbGRDb21wbGV0ZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYW5pbUNvbXBsZXRlKCkge1xuICAgICAgICAgICAgZWxlbWVudC5jc3MoIHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBcInZpc2libGVcIlxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgJCggcGllY2VzICkucmVtb3ZlKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9ICk7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIEZhZGUgMS4xMi4xXG4gICAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqL1xuXG4gICAgLy8+PmxhYmVsOiBGYWRlIEVmZmVjdFxuICAgIC8vPj5ncm91cDogRWZmZWN0c1xuICAgIC8vPj5kZXNjcmlwdGlvbjogRmFkZXMgdGhlIGVsZW1lbnQuXG4gICAgLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2ZhZGUtZWZmZWN0L1xuICAgIC8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG4gICAgdmFyIGVmZmVjdHNFZmZlY3RGYWRlID0gJC5lZmZlY3RzLmRlZmluZSggXCJmYWRlXCIsIFwidG9nZ2xlXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuICAgICAgICB2YXIgc2hvdyA9IG9wdGlvbnMubW9kZSA9PT0gXCJzaG93XCI7XG5cbiAgICAgICAgJCggdGhpcyApXG4gICAgICAgICAgICAuY3NzKCBcIm9wYWNpdHlcIiwgc2hvdyA/IDAgOiAxIClcbiAgICAgICAgICAgIC5hbmltYXRlKCB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogc2hvdyA/IDEgOiAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGRvbmVcbiAgICAgICAgICAgIH0gKTtcbiAgICB9ICk7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIEZvbGQgMS4xMi4xXG4gICAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqL1xuXG4gICAgLy8+PmxhYmVsOiBGb2xkIEVmZmVjdFxuICAgIC8vPj5ncm91cDogRWZmZWN0c1xuICAgIC8vPj5kZXNjcmlwdGlvbjogRm9sZHMgYW4gZWxlbWVudCBmaXJzdCBob3Jpem9udGFsbHkgYW5kIHRoZW4gdmVydGljYWxseS5cbiAgICAvLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZm9sZC1lZmZlY3QvXG4gICAgLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbiAgICB2YXIgZWZmZWN0c0VmZmVjdEZvbGQgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImZvbGRcIiwgXCJoaWRlXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuXG4gICAgICAgIC8vIENyZWF0ZSBlbGVtZW50XG4gICAgICAgIHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgIHNob3cgPSBtb2RlID09PSBcInNob3dcIixcbiAgICAgICAgICAgIGhpZGUgPSBtb2RlID09PSBcImhpZGVcIixcbiAgICAgICAgICAgIHNpemUgPSBvcHRpb25zLnNpemUgfHwgMTUsXG4gICAgICAgICAgICBwZXJjZW50ID0gLyhbMC05XSspJS8uZXhlYyggc2l6ZSApLFxuICAgICAgICAgICAgaG9yaXpGaXJzdCA9ICEhb3B0aW9ucy5ob3JpekZpcnN0LFxuICAgICAgICAgICAgcmVmID0gaG9yaXpGaXJzdCA/IFsgXCJyaWdodFwiLCBcImJvdHRvbVwiIF0gOiBbIFwiYm90dG9tXCIsIFwicmlnaHRcIiBdLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIC8gMixcblxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSAkLmVmZmVjdHMuY3JlYXRlUGxhY2Vob2xkZXIoIGVsZW1lbnQgKSxcblxuICAgICAgICAgICAgc3RhcnQgPSBlbGVtZW50LmNzc0NsaXAoKSxcbiAgICAgICAgICAgIGFuaW1hdGlvbjEgPSB7IGNsaXA6ICQuZXh0ZW5kKCB7fSwgc3RhcnQgKSB9LFxuICAgICAgICAgICAgYW5pbWF0aW9uMiA9IHsgY2xpcDogJC5leHRlbmQoIHt9LCBzdGFydCApIH0sXG5cbiAgICAgICAgICAgIGRpc3RhbmNlID0gWyBzdGFydFsgcmVmWyAwIF0gXSwgc3RhcnRbIHJlZlsgMSBdIF0gXSxcblxuICAgICAgICAgICAgcXVldWVsZW4gPSBlbGVtZW50LnF1ZXVlKCkubGVuZ3RoO1xuXG4gICAgICAgIGlmICggcGVyY2VudCApIHtcbiAgICAgICAgICAgIHNpemUgPSBwYXJzZUludCggcGVyY2VudFsgMSBdLCAxMCApIC8gMTAwICogZGlzdGFuY2VbIGhpZGUgPyAwIDogMSBdO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbjEuY2xpcFsgcmVmWyAwIF0gXSA9IHNpemU7XG4gICAgICAgIGFuaW1hdGlvbjIuY2xpcFsgcmVmWyAwIF0gXSA9IHNpemU7XG4gICAgICAgIGFuaW1hdGlvbjIuY2xpcFsgcmVmWyAxIF0gXSA9IDA7XG5cbiAgICAgICAgaWYgKCBzaG93ICkge1xuICAgICAgICAgICAgZWxlbWVudC5jc3NDbGlwKCBhbmltYXRpb24yLmNsaXAgKTtcbiAgICAgICAgICAgIGlmICggcGxhY2Vob2xkZXIgKSB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuY3NzKCAkLmVmZmVjdHMuY2xpcFRvQm94KCBhbmltYXRpb24yICkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5pbWF0aW9uMi5jbGlwID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltYXRlXG4gICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgIC5xdWV1ZSggZnVuY3Rpb24oIG5leHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBwbGFjZWhvbGRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hbmltYXRlKCAkLmVmZmVjdHMuY2xpcFRvQm94KCBhbmltYXRpb24xICksIGR1cmF0aW9uLCBvcHRpb25zLmVhc2luZyApXG4gICAgICAgICAgICAgICAgICAgICAgICAuYW5pbWF0ZSggJC5lZmZlY3RzLmNsaXBUb0JveCggYW5pbWF0aW9uMiApLCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9IClcbiAgICAgICAgICAgIC5hbmltYXRlKCBhbmltYXRpb24xLCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKVxuICAgICAgICAgICAgLmFuaW1hdGUoIGFuaW1hdGlvbjIsIGR1cmF0aW9uLCBvcHRpb25zLmVhc2luZyApXG4gICAgICAgICAgICAucXVldWUoIGRvbmUgKTtcblxuICAgICAgICAkLmVmZmVjdHMudW5zaGlmdCggZWxlbWVudCwgcXVldWVsZW4sIDQgKTtcbiAgICB9ICk7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIEhpZ2hsaWdodCAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IEhpZ2hsaWdodCBFZmZlY3RcbiAgICAvLz4+Z3JvdXA6IEVmZmVjdHNcbiAgICAvLz4+ZGVzY3JpcHRpb246IEhpZ2hsaWdodHMgdGhlIGJhY2tncm91bmQgb2YgYW4gZWxlbWVudCBpbiBhIGRlZmluZWQgY29sb3IgZm9yIGEgY3VzdG9tIGR1cmF0aW9uLlxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9oaWdobGlnaHQtZWZmZWN0L1xuICAgIC8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG4gICAgdmFyIGVmZmVjdHNFZmZlY3RIaWdobGlnaHQgPSAkLmVmZmVjdHMuZGVmaW5lKCBcImhpZ2hsaWdodFwiLCBcInNob3dcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gJCggdGhpcyApLFxuICAgICAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogZWxlbWVudC5jc3MoIFwiYmFja2dyb3VuZENvbG9yXCIgKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoIG9wdGlvbnMubW9kZSA9PT0gXCJoaWRlXCIgKSB7XG4gICAgICAgICAgICBhbmltYXRpb24ub3BhY2l0eSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAkLmVmZmVjdHMuc2F2ZVN0eWxlKCBlbGVtZW50ICk7XG5cbiAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgLmNzcygge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmNvbG9yIHx8IFwiI2ZmZmY5OVwiXG4gICAgICAgICAgICB9IClcbiAgICAgICAgICAgIC5hbmltYXRlKCBhbmltYXRpb24sIHtcbiAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZG9uZVxuICAgICAgICAgICAgfSApO1xuICAgIH0gKTtcblxuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IFVJIEVmZmVjdHMgU2l6ZSAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IFNpemUgRWZmZWN0XG4gICAgLy8+Pmdyb3VwOiBFZmZlY3RzXG4gICAgLy8+PmRlc2NyaXB0aW9uOiBSZXNpemUgYW4gZWxlbWVudCB0byBhIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zaXplLWVmZmVjdC9cbiAgICAvLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxuICAgIHZhciBlZmZlY3RzRWZmZWN0U2l6ZSA9ICQuZWZmZWN0cy5kZWZpbmUoIFwic2l6ZVwiLCBmdW5jdGlvbiggb3B0aW9ucywgZG9uZSApIHtcblxuICAgICAgICAvLyBDcmVhdGUgZWxlbWVudFxuICAgICAgICB2YXIgYmFzZWxpbmUsIGZhY3RvciwgdGVtcCxcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkKCB0aGlzICksXG5cbiAgICAgICAgICAgIC8vIENvcHkgZm9yIGNoaWxkcmVuXG4gICAgICAgICAgICBjUHJvcHMgPSBbIFwiZm9udFNpemVcIiBdLFxuICAgICAgICAgICAgdlByb3BzID0gWyBcImJvcmRlclRvcFdpZHRoXCIsIFwiYm9yZGVyQm90dG9tV2lkdGhcIiwgXCJwYWRkaW5nVG9wXCIsIFwicGFkZGluZ0JvdHRvbVwiIF0sXG4gICAgICAgICAgICBoUHJvcHMgPSBbIFwiYm9yZGVyTGVmdFdpZHRoXCIsIFwiYm9yZGVyUmlnaHRXaWR0aFwiLCBcInBhZGRpbmdMZWZ0XCIsIFwicGFkZGluZ1JpZ2h0XCIgXSxcblxuICAgICAgICAgICAgLy8gU2V0IG9wdGlvbnNcbiAgICAgICAgICAgIG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgICByZXN0b3JlID0gbW9kZSAhPT0gXCJlZmZlY3RcIixcbiAgICAgICAgICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCBcImJvdGhcIixcbiAgICAgICAgICAgIG9yaWdpbiA9IG9wdGlvbnMub3JpZ2luIHx8IFsgXCJtaWRkbGVcIiwgXCJjZW50ZXJcIiBdLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBlbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICksXG4gICAgICAgICAgICBwb3MgPSBlbGVtZW50LnBvc2l0aW9uKCksXG4gICAgICAgICAgICBvcmlnaW5hbCA9ICQuZWZmZWN0cy5zY2FsZWREaW1lbnNpb25zKCBlbGVtZW50ICksXG4gICAgICAgICAgICBmcm9tID0gb3B0aW9ucy5mcm9tIHx8IG9yaWdpbmFsLFxuICAgICAgICAgICAgdG8gPSBvcHRpb25zLnRvIHx8ICQuZWZmZWN0cy5zY2FsZWREaW1lbnNpb25zKCBlbGVtZW50LCAwICk7XG5cbiAgICAgICAgJC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cbiAgICAgICAgaWYgKCBtb2RlID09PSBcInNob3dcIiApIHtcbiAgICAgICAgICAgIHRlbXAgPSBmcm9tO1xuICAgICAgICAgICAgZnJvbSA9IHRvO1xuICAgICAgICAgICAgdG8gPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHNjYWxpbmcgZmFjdG9yXG4gICAgICAgIGZhY3RvciA9IHtcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgICB5OiBmcm9tLmhlaWdodCAvIG9yaWdpbmFsLmhlaWdodCxcbiAgICAgICAgICAgICAgICB4OiBmcm9tLndpZHRoIC8gb3JpZ2luYWwud2lkdGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgIHk6IHRvLmhlaWdodCAvIG9yaWdpbmFsLmhlaWdodCxcbiAgICAgICAgICAgICAgICB4OiB0by53aWR0aCAvIG9yaWdpbmFsLndpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIGNzcyBib3hcbiAgICAgICAgaWYgKCBzY2FsZSA9PT0gXCJib3hcIiB8fCBzY2FsZSA9PT0gXCJib3RoXCIgKSB7XG5cbiAgICAgICAgICAgIC8vIFZlcnRpY2FsIHByb3BzIHNjYWxpbmdcbiAgICAgICAgICAgIGlmICggZmFjdG9yLmZyb20ueSAhPT0gZmFjdG9yLnRvLnkgKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGZyb20gKTtcbiAgICAgICAgICAgICAgICB0byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCB2UHJvcHMsIGZhY3Rvci50by55LCB0byApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIb3Jpem9udGFsIHByb3BzIHNjYWxpbmdcbiAgICAgICAgICAgIGlmICggZmFjdG9yLmZyb20ueCAhPT0gZmFjdG9yLnRvLnggKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCBoUHJvcHMsIGZhY3Rvci5mcm9tLngsIGZyb20gKTtcbiAgICAgICAgICAgICAgICB0byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBlbGVtZW50LCBoUHJvcHMsIGZhY3Rvci50by54LCB0byApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NhbGUgdGhlIGNvbnRlbnRcbiAgICAgICAgaWYgKCBzY2FsZSA9PT0gXCJjb250ZW50XCIgfHwgc2NhbGUgPT09IFwiYm90aFwiICkge1xuXG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXG4gICAgICAgICAgICBpZiAoIGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55ICkge1xuICAgICAgICAgICAgICAgIGZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWxlbWVudCwgY1Byb3BzLCBmYWN0b3IuZnJvbS55LCBmcm9tICk7XG4gICAgICAgICAgICAgICAgdG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbiggZWxlbWVudCwgY1Byb3BzLCBmYWN0b3IudG8ueSwgdG8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkanVzdCB0aGUgcG9zaXRpb24gcHJvcGVydGllcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3JpZ2luIHBvaW50c1xuICAgICAgICBpZiAoIG9yaWdpbiApIHtcbiAgICAgICAgICAgIGJhc2VsaW5lID0gJC5lZmZlY3RzLmdldEJhc2VsaW5lKCBvcmlnaW4sIG9yaWdpbmFsICk7XG4gICAgICAgICAgICBmcm9tLnRvcCA9ICggb3JpZ2luYWwub3V0ZXJIZWlnaHQgLSBmcm9tLm91dGVySGVpZ2h0ICkgKiBiYXNlbGluZS55ICsgcG9zLnRvcDtcbiAgICAgICAgICAgIGZyb20ubGVmdCA9ICggb3JpZ2luYWwub3V0ZXJXaWR0aCAtIGZyb20ub3V0ZXJXaWR0aCApICogYmFzZWxpbmUueCArIHBvcy5sZWZ0O1xuICAgICAgICAgICAgdG8udG9wID0gKCBvcmlnaW5hbC5vdXRlckhlaWdodCAtIHRvLm91dGVySGVpZ2h0ICkgKiBiYXNlbGluZS55ICsgcG9zLnRvcDtcbiAgICAgICAgICAgIHRvLmxlZnQgPSAoIG9yaWdpbmFsLm91dGVyV2lkdGggLSB0by5vdXRlcldpZHRoICkgKiBiYXNlbGluZS54ICsgcG9zLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5jc3MoIGZyb20gKTtcblxuICAgICAgICAvLyBBbmltYXRlIHRoZSBjaGlsZHJlbiBpZiBkZXNpcmVkXG4gICAgICAgIGlmICggc2NhbGUgPT09IFwiY29udGVudFwiIHx8IHNjYWxlID09PSBcImJvdGhcIiApIHtcblxuICAgICAgICAgICAgdlByb3BzID0gdlByb3BzLmNvbmNhdCggWyBcIm1hcmdpblRvcFwiLCBcIm1hcmdpbkJvdHRvbVwiIF0gKS5jb25jYXQoIGNQcm9wcyApO1xuICAgICAgICAgICAgaFByb3BzID0gaFByb3BzLmNvbmNhdCggWyBcIm1hcmdpbkxlZnRcIiwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblxuICAgICAgICAgICAgLy8gT25seSBhbmltYXRlIGNoaWxkcmVuIHdpdGggd2lkdGggYXR0cmlidXRlcyBzcGVjaWZpZWRcbiAgICAgICAgICAgIC8vIFRPRE86IGlzIHRoaXMgcmlnaHQ/IHNob3VsZCB3ZSBpbmNsdWRlIGFueXRoaW5nIHdpdGggY3NzIHdpZHRoIHNwZWNpZmllZCBhcyB3ZWxsXG4gICAgICAgICAgICBlbGVtZW50LmZpbmQoIFwiKlt3aWR0aF1cIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRPcmlnaW5hbCA9ICQuZWZmZWN0cy5zY2FsZWREaW1lbnNpb25zKCBjaGlsZCApLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZEZyb20gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNoaWxkT3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjaGlsZE9yaWdpbmFsLndpZHRoICogZmFjdG9yLmZyb20ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySGVpZ2h0OiBjaGlsZE9yaWdpbmFsLm91dGVySGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyV2lkdGg6IGNoaWxkT3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3Rvci5mcm9tLnhcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2hpbGRPcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjaGlsZE9yaWdpbmFsLndpZHRoICogZmFjdG9yLnRvLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckhlaWdodDogY2hpbGRPcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyV2lkdGg6IGNoaWxkT3JpZ2luYWwud2lkdGggKiBmYWN0b3IudG8ueFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xuICAgICAgICAgICAgICAgIGlmICggZmFjdG9yLmZyb20ueSAhPT0gZmFjdG9yLnRvLnkgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgdlByb3BzLCBmYWN0b3IuZnJvbS55LCBjaGlsZEZyb20gKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUbyA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgdlByb3BzLCBmYWN0b3IudG8ueSwgY2hpbGRUbyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgcHJvcHMgc2NhbGluZ1xuICAgICAgICAgICAgICAgIGlmICggZmFjdG9yLmZyb20ueCAhPT0gZmFjdG9yLnRvLnggKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBjaGlsZEZyb20gKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUbyA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKCBjaGlsZCwgaFByb3BzLCBmYWN0b3IudG8ueCwgY2hpbGRUbyApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggcmVzdG9yZSApIHtcbiAgICAgICAgICAgICAgICAgICAgJC5lZmZlY3RzLnNhdmVTdHlsZSggY2hpbGQgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBbmltYXRlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hpbGQuY3NzKCBjaGlsZEZyb20gKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5hbmltYXRlKCBjaGlsZFRvLCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHJlc3RvcmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVmZmVjdHMucmVzdG9yZVN0eWxlKCBjaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5pbWF0ZVxuICAgICAgICBlbGVtZW50LmFuaW1hdGUoIHRvLCB7XG4gICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZWxlbWVudC5vZmZzZXQoKTtcblxuICAgICAgICAgICAgICAgIGlmICggdG8ub3BhY2l0eSA9PT0gMCApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoIFwib3BhY2l0eVwiLCBmcm9tLm9wYWNpdHkgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoICFyZXN0b3JlICkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCBcInBvc2l0aW9uXCIsIHBvc2l0aW9uID09PSBcInN0YXRpY1wiID8gXCJyZWxhdGl2ZVwiIDogcG9zaXRpb24gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9mZnNldCggb2Zmc2V0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBzYXZlIHN0eWxlIGhlcmUgc28gdGhhdCBhdXRvbWF0aWMgc3R5bGUgcmVzdG9yYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lc24ndCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBzdHlsZXMgZnJvbSBiZWZvcmUgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgJC5lZmZlY3RzLnNhdmVTdHlsZSggZWxlbWVudCApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSApO1xuXG4gICAgfSApO1xuXG5cbiAgICAvKiFcbiAgICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBTY2FsZSAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IFNjYWxlIEVmZmVjdFxuICAgIC8vPj5ncm91cDogRWZmZWN0c1xuICAgIC8vPj5kZXNjcmlwdGlvbjogR3Jvd3Mgb3Igc2hyaW5rcyBhbiBlbGVtZW50IGFuZCBpdHMgY29udGVudC5cbiAgICAvLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2NhbGUtZWZmZWN0L1xuICAgIC8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS9lZmZlY3QvXG5cblxuXG4gICAgdmFyIGVmZmVjdHNFZmZlY3RTY2FsZSA9ICQuZWZmZWN0cy5kZWZpbmUoIFwic2NhbGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGVsZW1lbnRcbiAgICAgICAgdmFyIGVsID0gJCggdGhpcyApLFxuICAgICAgICAgICAgbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgIHBlcmNlbnQgPSBwYXJzZUludCggb3B0aW9ucy5wZXJjZW50LCAxMCApIHx8XG4gICAgICAgICAgICAgICAgKCBwYXJzZUludCggb3B0aW9ucy5wZXJjZW50LCAxMCApID09PSAwID8gMCA6ICggbW9kZSAhPT0gXCJlZmZlY3RcIiA/IDAgOiAxMDAgKSApLFxuXG4gICAgICAgICAgICBuZXdPcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAkLmVmZmVjdHMuc2NhbGVkRGltZW5zaW9ucyggZWwgKSxcbiAgICAgICAgICAgICAgICB0bzogJC5lZmZlY3RzLnNjYWxlZERpbWVuc2lvbnMoIGVsLCBwZXJjZW50LCBvcHRpb25zLmRpcmVjdGlvbiB8fCBcImJvdGhcIiApLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4gfHwgWyBcIm1pZGRsZVwiLCBcImNlbnRlclwiIF1cbiAgICAgICAgICAgIH0sIG9wdGlvbnMgKTtcblxuICAgICAgICAvLyBGYWRlIG9wdGlvbiB0byBzdXBwb3J0IHB1ZmZcbiAgICAgICAgaWYgKCBvcHRpb25zLmZhZGUgKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zLmZyb20ub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICBuZXdPcHRpb25zLnRvLm9wYWNpdHkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgJC5lZmZlY3RzLmVmZmVjdC5zaXplLmNhbGwoIHRoaXMsIG5ld09wdGlvbnMsIGRvbmUgKTtcbiAgICB9ICk7XG5cblxuICAgIC8qIVxuICAgICAqIGpRdWVyeSBVSSBFZmZlY3RzIFB1ZmYgMS4xMi4xXG4gICAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqL1xuXG4gICAgLy8+PmxhYmVsOiBQdWZmIEVmZmVjdFxuICAgIC8vPj5ncm91cDogRWZmZWN0c1xuICAgIC8vPj5kZXNjcmlwdGlvbjogQ3JlYXRlcyBhIHB1ZmYgZWZmZWN0IGJ5IHNjYWxpbmcgdGhlIGVsZW1lbnQgdXAgYW5kIGhpZGluZyBpdCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wdWZmLWVmZmVjdC9cbiAgICAvLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxuICAgIHZhciBlZmZlY3RzRWZmZWN0UHVmZiA9ICQuZWZmZWN0cy5kZWZpbmUoIFwicHVmZlwiLCBcImhpZGVcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG4gICAgICAgIHZhciBuZXdPcHRpb25zID0gJC5leHRlbmQoIHRydWUsIHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBmYWRlOiB0cnVlLFxuICAgICAgICAgICAgcGVyY2VudDogcGFyc2VJbnQoIG9wdGlvbnMucGVyY2VudCwgMTAgKSB8fCAxNTBcbiAgICAgICAgfSApO1xuXG4gICAgICAgICQuZWZmZWN0cy5lZmZlY3Quc2NhbGUuY2FsbCggdGhpcywgbmV3T3B0aW9ucywgZG9uZSApO1xuICAgIH0gKTtcblxuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IFVJIEVmZmVjdHMgUHVsc2F0ZSAxLjEyLjFcbiAgICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gICAgICpcbiAgICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAgICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gICAgICovXG5cbiAgICAvLz4+bGFiZWw6IFB1bHNhdGUgRWZmZWN0XG4gICAgLy8+Pmdyb3VwOiBFZmZlY3RzXG4gICAgLy8+PmRlc2NyaXB0aW9uOiBQdWxzYXRlcyBhbiBlbGVtZW50IG4gdGltZXMgYnkgY2hhbmdpbmcgdGhlIG9wYWNpdHkgdG8gemVybyBhbmQgYmFjay5cbiAgICAvLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcHVsc2F0ZS1lZmZlY3QvXG4gICAgLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbiAgICB2YXIgZWZmZWN0c0VmZmVjdFB1bHNhdGUgPSAkLmVmZmVjdHMuZGVmaW5lKCBcInB1bHNhdGVcIiwgXCJzaG93XCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgIG1vZGUgPSBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgICBzaG93ID0gbW9kZSA9PT0gXCJzaG93XCIsXG4gICAgICAgICAgICBoaWRlID0gbW9kZSA9PT0gXCJoaWRlXCIsXG4gICAgICAgICAgICBzaG93aGlkZSA9IHNob3cgfHwgaGlkZSxcblxuICAgICAgICAgICAgLy8gU2hvd2luZyBvciBoaWRpbmcgbGVhdmVzIG9mZiB0aGUgXCJsYXN0XCIgYW5pbWF0aW9uXG4gICAgICAgICAgICBhbmltcyA9ICggKCBvcHRpb25zLnRpbWVzIHx8IDUgKSAqIDIgKSArICggc2hvd2hpZGUgPyAxIDogMCApLFxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIC8gYW5pbXMsXG4gICAgICAgICAgICBhbmltYXRlVG8gPSAwLFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBxdWV1ZWxlbiA9IGVsZW1lbnQucXVldWUoKS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCBzaG93IHx8ICFlbGVtZW50LmlzKCBcIjp2aXNpYmxlXCIgKSApIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKTtcbiAgICAgICAgICAgIGFuaW1hdGVUbyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmltcyAtIDEgb3BhY2l0eSBcInRvZ2dsZXNcIlxuICAgICAgICBmb3IgKCA7IGkgPCBhbmltczsgaSsrICkge1xuICAgICAgICAgICAgZWxlbWVudC5hbmltYXRlKCB7IG9wYWNpdHk6IGFuaW1hdGVUbyB9LCBkdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcgKTtcbiAgICAgICAgICAgIGFuaW1hdGVUbyA9IDEgLSBhbmltYXRlVG87XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmFuaW1hdGUoIHsgb3BhY2l0eTogYW5pbWF0ZVRvIH0sIGR1cmF0aW9uLCBvcHRpb25zLmVhc2luZyApO1xuXG4gICAgICAgIGVsZW1lbnQucXVldWUoIGRvbmUgKTtcblxuICAgICAgICAkLmVmZmVjdHMudW5zaGlmdCggZWxlbWVudCwgcXVldWVsZW4sIGFuaW1zICsgMSApO1xuICAgIH0gKTtcblxuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IFVJIEVmZmVjdHMgU2hha2UgMS4xMi4xXG4gICAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqL1xuXG4gICAgLy8+PmxhYmVsOiBTaGFrZSBFZmZlY3RcbiAgICAvLz4+Z3JvdXA6IEVmZmVjdHNcbiAgICAvLz4+ZGVzY3JpcHRpb246IFNoYWtlcyBhbiBlbGVtZW50IGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5IG4gdGltZXMuXG4gICAgLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NoYWtlLWVmZmVjdC9cbiAgICAvLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZWZmZWN0L1xuXG5cblxuICAgIHZhciBlZmZlY3RzRWZmZWN0U2hha2UgPSAkLmVmZmVjdHMuZGVmaW5lKCBcInNoYWtlXCIsIGZ1bmN0aW9uKCBvcHRpb25zLCBkb25lICkge1xuXG4gICAgICAgIHZhciBpID0gMSxcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkKCB0aGlzICksXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBcImxlZnRcIixcbiAgICAgICAgICAgIGRpc3RhbmNlID0gb3B0aW9ucy5kaXN0YW5jZSB8fCAyMCxcbiAgICAgICAgICAgIHRpbWVzID0gb3B0aW9ucy50aW1lcyB8fCAzLFxuICAgICAgICAgICAgYW5pbXMgPSB0aW1lcyAqIDIgKyAxLFxuICAgICAgICAgICAgc3BlZWQgPSBNYXRoLnJvdW5kKCBvcHRpb25zLmR1cmF0aW9uIC8gYW5pbXMgKSxcbiAgICAgICAgICAgIHJlZiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiApID8gXCJ0b3BcIiA6IFwibGVmdFwiLFxuICAgICAgICAgICAgcG9zaXRpdmVNb3Rpb24gPSAoIGRpcmVjdGlvbiA9PT0gXCJ1cFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgKSxcbiAgICAgICAgICAgIGFuaW1hdGlvbiA9IHt9LFxuICAgICAgICAgICAgYW5pbWF0aW9uMSA9IHt9LFxuICAgICAgICAgICAgYW5pbWF0aW9uMiA9IHt9LFxuXG4gICAgICAgICAgICBxdWV1ZWxlbiA9IGVsZW1lbnQucXVldWUoKS5sZW5ndGg7XG5cbiAgICAgICAgJC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cbiAgICAgICAgLy8gQW5pbWF0aW9uXG4gICAgICAgIGFuaW1hdGlvblsgcmVmIF0gPSAoIHBvc2l0aXZlTW90aW9uID8gXCItPVwiIDogXCIrPVwiICkgKyBkaXN0YW5jZTtcbiAgICAgICAgYW5pbWF0aW9uMVsgcmVmIF0gPSAoIHBvc2l0aXZlTW90aW9uID8gXCIrPVwiIDogXCItPVwiICkgKyBkaXN0YW5jZSAqIDI7XG4gICAgICAgIGFuaW1hdGlvbjJbIHJlZiBdID0gKCBwb3NpdGl2ZU1vdGlvbiA/IFwiLT1cIiA6IFwiKz1cIiApICsgZGlzdGFuY2UgKiAyO1xuXG4gICAgICAgIC8vIEFuaW1hdGVcbiAgICAgICAgZWxlbWVudC5hbmltYXRlKCBhbmltYXRpb24sIHNwZWVkLCBvcHRpb25zLmVhc2luZyApO1xuXG4gICAgICAgIC8vIFNoYWtlc1xuICAgICAgICBmb3IgKCA7IGkgPCB0aW1lczsgaSsrICkge1xuICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAgIC5hbmltYXRlKCBhbmltYXRpb24xLCBzcGVlZCwgb3B0aW9ucy5lYXNpbmcgKVxuICAgICAgICAgICAgICAgIC5hbmltYXRlKCBhbmltYXRpb24yLCBzcGVlZCwgb3B0aW9ucy5lYXNpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgIC5hbmltYXRlKCBhbmltYXRpb24xLCBzcGVlZCwgb3B0aW9ucy5lYXNpbmcgKVxuICAgICAgICAgICAgLmFuaW1hdGUoIGFuaW1hdGlvbiwgc3BlZWQgLyAyLCBvcHRpb25zLmVhc2luZyApXG4gICAgICAgICAgICAucXVldWUoIGRvbmUgKTtcblxuICAgICAgICAkLmVmZmVjdHMudW5zaGlmdCggZWxlbWVudCwgcXVldWVsZW4sIGFuaW1zICsgMSApO1xuICAgIH0gKTtcblxuXG4gICAgLyohXG4gICAgICogalF1ZXJ5IFVJIEVmZmVjdHMgU2xpZGUgMS4xMi4xXG4gICAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICAgICAqL1xuXG4gICAgLy8+PmxhYmVsOiBTbGlkZSBFZmZlY3RcbiAgICAvLz4+Z3JvdXA6IEVmZmVjdHNcbiAgICAvLz4+ZGVzY3JpcHRpb246IFNsaWRlcyBhbiBlbGVtZW50IGluIGFuZCBvdXQgb2YgdGhlIHZpZXdwb3J0LlxuICAgIC8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zbGlkZS1lZmZlY3QvXG4gICAgLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL2VmZmVjdC9cblxuXG5cbiAgICB2YXIgZWZmZWN0c0VmZmVjdFNsaWRlID0gJC5lZmZlY3RzLmRlZmluZSggXCJzbGlkZVwiLCBcInNob3dcIiwgZnVuY3Rpb24oIG9wdGlvbnMsIGRvbmUgKSB7XG4gICAgICAgIHZhciBzdGFydENsaXAsIHN0YXJ0UmVmLFxuICAgICAgICAgICAgZWxlbWVudCA9ICQoIHRoaXMgKSxcbiAgICAgICAgICAgIG1hcCA9IHtcbiAgICAgICAgICAgICAgICB1cDogWyBcImJvdHRvbVwiLCBcInRvcFwiIF0sXG4gICAgICAgICAgICAgICAgZG93bjogWyBcInRvcFwiLCBcImJvdHRvbVwiIF0sXG4gICAgICAgICAgICAgICAgbGVmdDogWyBcInJpZ2h0XCIsIFwibGVmdFwiIF0sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IFsgXCJsZWZ0XCIsIFwicmlnaHRcIiBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZSA9IG9wdGlvbnMubW9kZSxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8IFwibGVmdFwiLFxuICAgICAgICAgICAgcmVmID0gKCBkaXJlY3Rpb24gPT09IFwidXBcIiB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiICkgPyBcInRvcFwiIDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBwb3NpdGl2ZU1vdGlvbiA9ICggZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcImxlZnRcIiApLFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlIHx8XG4gICAgICAgICAgICAgICAgZWxlbWVudFsgcmVmID09PSBcInRvcFwiID8gXCJvdXRlckhlaWdodFwiIDogXCJvdXRlcldpZHRoXCIgXSggdHJ1ZSApLFxuICAgICAgICAgICAgYW5pbWF0aW9uID0ge307XG5cbiAgICAgICAgJC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKCBlbGVtZW50ICk7XG5cbiAgICAgICAgc3RhcnRDbGlwID0gZWxlbWVudC5jc3NDbGlwKCk7XG4gICAgICAgIHN0YXJ0UmVmID0gZWxlbWVudC5wb3NpdGlvbigpWyByZWYgXTtcblxuICAgICAgICAvLyBEZWZpbmUgaGlkZSBhbmltYXRpb25cbiAgICAgICAgYW5pbWF0aW9uWyByZWYgXSA9ICggcG9zaXRpdmVNb3Rpb24gPyAtMSA6IDEgKSAqIGRpc3RhbmNlICsgc3RhcnRSZWY7XG4gICAgICAgIGFuaW1hdGlvbi5jbGlwID0gZWxlbWVudC5jc3NDbGlwKCk7XG4gICAgICAgIGFuaW1hdGlvbi5jbGlwWyBtYXBbIGRpcmVjdGlvbiBdWyAxIF0gXSA9IGFuaW1hdGlvbi5jbGlwWyBtYXBbIGRpcmVjdGlvbiBdWyAwIF0gXTtcblxuICAgICAgICAvLyBSZXZlcnNlIHRoZSBhbmltYXRpb24gaWYgd2UncmUgc2hvd2luZ1xuICAgICAgICBpZiAoIG1vZGUgPT09IFwic2hvd1wiICkge1xuICAgICAgICAgICAgZWxlbWVudC5jc3NDbGlwKCBhbmltYXRpb24uY2xpcCApO1xuICAgICAgICAgICAgZWxlbWVudC5jc3MoIHJlZiwgYW5pbWF0aW9uWyByZWYgXSApO1xuICAgICAgICAgICAgYW5pbWF0aW9uLmNsaXAgPSBzdGFydENsaXA7XG4gICAgICAgICAgICBhbmltYXRpb25bIHJlZiBdID0gc3RhcnRSZWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxseSBhbmltYXRlXG4gICAgICAgIGVsZW1lbnQuYW5pbWF0ZSggYW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgICAgICBjb21wbGV0ZTogZG9uZVxuICAgICAgICB9ICk7XG4gICAgfSApO1xufSkoIGpRdWVyeSApO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZGV2L2pRdWVyeS5waWN0dXJlcy52aWV3cy5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUpBO0FBUUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBWkE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFaQTtBQUNBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBRUE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBTUE7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBVkE7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFqRUE7QUFtRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQVRBO0FBREE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBVEE7QUFEQTtBQWxCQTtBQWxFQTtBQXNHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBUkE7QUFyR0E7QUFDQTtBQUNBO0FBa0hBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9NQTtBQWlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBN0NBO0FBZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQWhCQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExSEE7QUE0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcE1BO0FBQ0E7QUFzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVBBO0FBQUE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcE1BO0FBQ0E7QUFzTUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQXBCQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQVpBO0FBQUE7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQWpCQTtBQUFBO0FBQUE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBWEE7QUFBQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBWkE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBRkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUEwQkE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ })
/******/ ]);